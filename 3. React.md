### Main concepts (components, jsx, props, virtual dom)

<details> 
<summary> 1. Что такое реакт и перечислите особенности его? </summary>

Это javascript - библиотека с открытым исходным кодом разработанной фейсбуком. Предназначена для создания пользовательских интерфейсов. 

К особенностям относится: 

1. компоненты; 

2. jsx; 

3. хуки; 

4. использование виртуального дома вместо реального;

</details>


<details> 
<summary> 2. Что такое компонент? И почему они должны начинаться с большой буквы? </summary>

Компоненты нужны для создания ui (пользовательского интерфейса) в реакте. По своей структуре компоненты предстоявляются небольшие блоки (куски) кода, которые мы можем использовать в разных местах нашего приложения. Они создаются с помощью классов, что является устаревшим методом, и с помощью функций.

---

Возможно это связано с соглашением самого реакта и указывает, что мы используем реакт с jsx. Если мы напишем компонент с маленькой буквы, то у нас будет ошибка.

</details>


<details>
<summary> 3. Что такое jsx?</summary>

`JSX` - расширения языка JS, который позволяет разработчику объединить JavaScript-кода  и HTML/XML в один файл. По сути, JSX - это синтаксический сахар React.createElement. Берет наш код, который в jsx и компилирует его в функцию React.createElement.

Можно ли использовать реакт без JSX?

Да, можно, нам просто нужно вместо компилятора уже самим писать return React.createElement.

```
function Greeting(props) {
  return React.createElement('div', null, 'Hello, ' + props.name + '!');
}

```

</details>

<details>
<summary> 4. Разница между компонентом и элементом?</summary>

Компонент возвращает jsx-разметку в котором хранятся элементы, сам компоненты мы не видим в браузере, а вот  элементы мы можем видеть.

</details>

<details>
<summary> 5. Разница между контролируемым и неконтролируемым компонентом? </summary>

Контролируемый компонент - это инпут за состоянием (state), которого мы можем следить. Например с помощью метода setState или использования хука useState

Неконтролируемый компонент - это инпут, состояние которого хранится внутри дома `и управляется браузером`, и чтобы его получить (значения) нужно исп refs.

</details>


<details>
<summary> 6. Что такое чистые компоненты (PureComponent)? </summary>

Чистый компонент — это компонент, у которого нет побочных эффектов, а также он избегает ненужного повторного рендеринга путем неглубокое сравнения предыдущего состояния и пропса с новым состоянм и пропсом, и если они одинаковые, то копмонент не перерисовываеть

</details>

<details>
<summary> 7. Чем фрагмент `<>` отличается от `div`? </summary>

В реакте необходимо оборочивать все теги в один общий контейнер и нам с этим помогает как фрагмент так и div. Фрагмент представляет собой пустые теги, но это сокращенный вариант от слова Fragment. Отличия: 

- Когда мы пишем div у нас создается дополнительный класс, а когда фрагмент то он пропускает добавления класса и сразу же переходит к дочерним тегам.

- Во фрагменте могут возникнуть проблемы с key, если мы исп сокращенный вариант, чтобы работать с ключом нам нужно импортировать из либы реакта фрагмент

</details>

<details>
<summary> 8. Что такое props? И чем он отличается от state? </summary>

Props расшифровывается как properties, он необходим нам для передачи каких-то данных от родительского компонента к дочернему, и потом на его основе он отрисовывает jsx разметку.

- Отличие: 

1. Props мы можем передавать компоненту, в то время как state находится внутри компонента. 
2. Пропсы иммутабельные (неизменяемые) в то время как state можем изменить внутри компонента через хук useState.

Стоит отметить, что никто нам не запрещает передавать стейт в качества пропса, однако стейт управляется только в родительском компоненте, то есть дочерним компонент не сможет влиять на состояние родительского. Для того, чтобьы дочерний смог взаимодействовать с родительским нужно использовать коллбеки

</details>

<details>
<summary> 9. Для чего нужен key ? Приведите пример его использования? </summary>

Когда мы хотим отрисовать список, то нам необходимо ключи. Они помогают реакту определить, какие элементы были изменены, добавлены или удалены, что в свою очередь увеличивает производительности рендеринга. В качестве ключей мы используем в основном ID. Если мы не укажем ключи, то он будет работать однако в консоле будет отображаться warning о том, что необходимо их добавить.

Дополнительный вопрос: почему index в key не лучшая практика?

- Могут возникнуть ошибка неправильной сортировка элементов списка, а также вставке новых элементов или удалении

</details>

<details>
<summary> 10. Что такое «бурение пропсов» (Prop Drilling)? Как его избежать?</summary>

Например: у нас есть большая вложенность компонентов, и нам необходимо передать пропсы в дочерние. Если это небольшая вложенность, то с этим проблем нет. А если это большое приложение, то очень затруднительно поддерживать, так как постоянно в дочерние компоненты необходимо добавлять пропсы и вытаскивать их. Чтобы решить данную проблему есть хук useContext или можно использовать стейт менеджмент redux, redux toolkit, effector

</details>

<details>
<summary> 11. Что такое виртуальный дом и как он работает? </summary>

Virtual-dom - это облегченная (легковесная) копия реального дома, которая представляет собой дерево объектов. Когда состояние компонента изменяется, то реакт обновляет виртуальный DOM, а после обновления виртуальный дом текущей версии сравнивается с предыдущим домом, находить изменения и вносит их уже в настоящий дом.

1. Дополнительный вопрос: что появляется первым Дом или Виртуал-дом? 

Сначало появляется дом, а затем на его основе виртуальный, потом виртуальный дом сравнивается с предыдущим домом и если видит изменения, то вносит уже в настоящий дом

2. Дополнительный вопрос: реакт увидил, что дивки разные, то как он будет работать? 

Сначало он отрисует в виртуал-доме, а потом возьмет эту дивку и заменит его в реальном доме. А если они одинаковые, то будет смотреть по содержанию

</details>