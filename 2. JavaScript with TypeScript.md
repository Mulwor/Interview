#### I. Основы

<details>
<summary> 1. Перечислите типы данных в JavaScript? </summary>
В JavaScript существует 8 типов данных, их можно разделить на примитивные и ссылочные. К примитивным относятся следующие типы:

- `string` (строка),

- `number` (число),

- `biginit`,

- `boolean`,

- `symbol` (уникальный идентификатор) - необходимо для создания уникальных id, чтобы создать его необходимо написать функцию Symbol(""). Если сравнить два одниковых символа между собой, они никогда не равны

- `null`,

- `undefined`

А к ссылочному относится:

- `object`. А определить тип данных можно с помощью typeOf.

<details>
<summary>Question: В чем отличие между null и undefined?</summary>

Стоит отметить, что разница между null и undefined в том, что `Undefined` - это когда переменная объявлена, но мы ей не присвоенно значение, а `null` - когда мы присвоили значение специально, и как бы говорим, что у нас есть переменная и она пустая.

</details>

<details>
<summary>Question: К какому типы данных относится массив и функция и чем они похожи?</summary>
Это все объект.
</details>

<details>
<summary> Question: В чем смысл объекта? И когда мы сравниваем объект, то что мы сравнимаем? Почему результат сравнения 2х объектов это false? </summary>

В нем можно хранить данные с помощью ключ и значения. Когда мы сравниваем объект, то мы сравниваем ссылки на объект

Примитивные типы данных сравниваются по значению, а объекты по ссылке. И если у нас две одинаковые объекты, то ссылки у них разные. Поэтому сравнения двух одинаковых объектов - это всегда false.

</details>

<details>
<summary>Question: Как превратить любой тип данных в булевое? Как преобразовать тип данных в булевой?</summary>

В JS мы можем явно преобразовать типы, всего их три: String(), Boolean(), Number() - и все они являются функциями.

Чтобы превартить тип данных в булевый можно использовать:

1. Функцию Boolean(null)
2. !! (Два логических не)

Чтобы превратить тип данных в числовое можно использовать:

1. Функцию Number('5')
2. метод parseInt("5")

Что превратить тип данных в строку можно использовать:

1. Функцию String(null)
2. Или через метод Object.prototype.toString(43)
</details>

<details>
<summary>Question: Перечислите все ложные значение? Перечислите falsy</summary>

Falsy - это следующие значение: "", 0, null, undefined, NaN, false. А все остальное уже true

</details>

<details>
<summary>Question: Что такое NaN? Как определить, что значение равно NaN?</summary>

NaN расшифровывается как not-a-number, что означает не является числом. Мы получаем его когда выполняем математическую операцию неправильно. Например, если мы возьмем строку и какое-то число, то оно нам даст NaN. А его особенностью можно выделить то, что она не равна ничему даже самому себе как в строгом, так и в нестрогом сравнении. Для того, чтобы проверить, что число не является числом использует функцию isNaN()

</details>

<details>
<summary>Question: разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?</summary>

Неявное преобразование происходит автоматически путем арифмитические действий, а явное когда мы указываем тип специально через функции Number или ParseInt, функцию String или метод toString, Boolean или двойное логическое !!

</details>

<details>
<summary>Question: JavaScript статически, или динамически типизированный язык? </summary>

Динамически типизированный язык, так как происходит автоматическое преобразование типов

</details>
</details>

<details>
<summary> 2. Какие операторы вы знаете? </summary>

I. Арифмитические операторы:

- сложения,
- вычитания,
- умножения,
- делание,
- возведение в стене `**`
- взятия от остатка `%`

II. Логические операторы:

- Или (||) - возвращает true, если одно из значений верно
- И (&&) - возвращает true только в том случае, если оба значеные верны, а вернет он последнее значение. Однако если все таки одно из значений false, то дальше он не пойдет.
- ! (Логическое не) - меняет значение на противоположное, стоит упомянуть также про

К особенностям стоит отметить, что есть также приоритетность, но если мы обернем в скобки то данная приоритетность уже не будет иметь разницы.

III. Операторы сравнения:

- больше, меньше, меньше или равно, больше или равно,
- нестрогое (==) и строгое равенство (===),
- не равно (!=).

<details>
<summary>Question: Чем отличается строгое равенство от нестрогового?</summary>

Строгое равенство отличается от нестрогого тем, что нестрогое сравнивает только значения без приведения типов, а строгая сравнивает и значения и типы

</details>

<details>
<summary>Question: Что такое двойное логическое не !!</summary>

Он нужен для преобразований значений к булевому значению.

Допилить идею: Если мы применим его к строке, то оно сначало станет булевое, а после этого к ней применится логическое отрицание.

</details>

<details>
<summary>Question: Что такое оператор нулевого слияние ??</summary>

Он возвращает значение правого операнда, если левый операнд содержит null или undefined, в противном случае возвращается значение левого операнда. Он похож на или, так как он возвращает правый операнд если в левом хранится ложное значение, а не только null / undefined

</details>

</details>

</details>

<details>
<summary>3. Циклы и инструкции</summary>

<details>
<summary> Что такое выражения (expression) и инструкции (statement)</summary>

I. Выражение - это арифмитическое действие. Например:`+, -, *, /, %, >, =, ==, i++, --i`, `Math.random - случайное число.

II. Инструкция - это фрагмент кода, который выполняет определенное действие. К инструкциям относятся: `if, if-else, while, for, for..in, for..of switch, for-in, объявления переменных`

</details>

<details>
<summary>Что такое switch/case и где он используется? </summary>

Заменители if...else, внутри которого есть кейсы (те в свою очередь делают строгое сравнения между значения), и после каждого кейса необходимо писать break, если не указать, то проверка пройдет дальше

Если говорить про реакт, то используется он в редьюсерах (редаксе). И например когда нам нужно именно точное сравнения

</details>

<details>
<summary> Какие есть и как работают циклы в JS? </summary>

Цикл - это когда нам необходимо какое-то действие повторить несколько раз

- for (let i=..; i > str; i++)
- for ... in
- for ... of

- While... — есть условия и по этой условия он будет выполняться, то есть он может даже и не выполнится
- Do...while — тело цикла будет выполняне один раз
</details>

<details>
<summary>В чем отличие между циклом for...in и for...of</summary>

Они служат для перебора объектов и массива. Если нам нужно перебрать объект, то мы использовать for...in, он возвращает нам ключи если нам необходимо перебрать массив, то мы используем for...of, он возвращает нам значенияю Однако если мы используем цикл for...in в массиве, то мы получем индексы.

</details>
</details>

<details>
<summary> 4. Методы в JavaSciprt, иммутабельность</summary>

<details>
<summary>Number and math methods</summary>

#### 1. Number method

- `.toString()` - берет число и преобразует его в строку
- `.parseInt()` - берет строку и преобразует в число
- `.isNaN()` - проверяет, является ли значения числа наном

#### 2. Math method

- `.min(1, 2, 3)` - вернуть минимальное число
- `.max(2, 3, 4)` - вернуть максимальное число
- `.random(1, 2, 3)` - можно получить рандомное число
- `.floor()` - округляет в меньшую степень
- `.ceil()` - округляет в большую степень
- `.pow(2, 3)` - принимает два значения и возвращает возведенную степень `(3, 3) // 27`
- `.abs()` - возвращает абсолютное значение числа. Если это пустые кавычки или пустой массив, то это
- `.trunc()` - удаляет точки после запятой

Ну и другие по типу косинуса, синуса метода

</details>

<details>
<summary>String methods</summary>

- `.toUpperCase()` - берет строку и пишет ее с большой буквы (преобразованное в верхний регистр).
- `.toLowerCase()` - берет строку и пишет ее с маленькой буквы (преобразованное в нижний регистр).
- `.split()` - делает из строки массив
- `.trim()` - удаляет пробельные символы с начало и конца строки

- `.startsWith()` проверяют начинается-ли строка с определенного символа который мы укажем внутри
- `.endsWith()` делает противоположное, тобишь заканчивается строка c определенным символом
- `.padStart()` => первым аргументом задается длина а вторым то что нужно подставляет подставить
- `.padEnd()` => работает также но теперь подставляет с конца

</details>

<details>
<summary>Array methods</summary>

- `.isArray()` => проверяет является ли значение массивом
- `.find()` - вернёт первый найденный в массиве элемент, который подходит под условие.
- `.findIndex()` - возвращает уже не найденный элемент, а индекс
- `.includes()` - определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false.

- `.indexOf()` - вернётся индекс первого найденного элемента или -1, если ничего не нашлось

Следующие 4 метода меняют исходных массив

- `.push()` - добавляет элементы в конец массива и возвращает новую длину массива.
- `.pop()` - удаляет из массива последний элемент и возвращает его значение.
- `.unshift()` - добавляет элементы в начало массива и возвращают новую длину массива.
- `.shift()` - удаляет из массива первый элемент и возвращает его значение.

Что будет работать быстрее? => Pop и push - так как их задача лишь добавить или удалить элемент в конце массива, а shift и unshift медленее так как помимо удаление или добавления первого элемент они будут сдвигать массив вправо или влево.

Разница между forEach() и map()

- `.forEach()` и `.map()` => отличие заключается в том, что forEach() меняет исходный массив, а map возвращает новый. Еще одним отличиям является то, что если мы используем .map, то мы можем использовать
  и другие методы.

- `.some()` - перебирает массив и смотрит соответвствует ли один конкретный элемент в массиве логическому условию.
- `.every()` - перебирает массив и смотрит соответвствует ли все элементы в массиве логическому условию.

```
[2, 5, 8, 1, 4].some(elem => elem > 10);                // false
[12, 5, 8, 1, 4].some(elem => elem > 10);               // true
[12, 5, 8, 130, 44].every(elem => elem >= 10);          // false
[12, 54, 18, 130, 44].every(elem => elem >= 10);        // true
```

Есть метод `.splice()` - который меняет исходный массив, c помощью данного метода мы можем удалять или добавлять внутрь массивы какие-то элементы

Есть также метод `slice()` - копирует старый массив и возвращает на его основе новый. Он просто копирует его.

- `.concat()` - когда есть два разных массива и нам нужна их объединить
- `.flat()` - когда внутри массива есть еще один массивы и мы хотим их все объединить в один общий через infinity либо указать определенную вложенность объединить, где 1 - на 1 уровень вложенности

const arr1 = [0, 1, 2, [3, 4]];
console.log(arr1.flat()); // Expected output: Array [0, 1, 2, 3, 4]

</details>

<details>
<summary>Какие методы массива мутируют?  </summary>

Splice, push, pop, shift, unshift

</details>

<details>
<summary>Что такое иммутабельность? И как достичь его? </summary>

Иммутабельность - это неизменяемый объект. Если мы хотим достичь иммутабельности, то мы можем использовать методы массива, такие как slice или map. К мутабельным относится push, shift, unshift, reverse. Если мы хотим, чтобы данные методы сработали, то есть были иммутабельными, то мы можем использовать spread оператор

</details>
</details>

<details>
<summary>5. Объект</summary>

<details>
<summary>Question: Расскажите про объект и как его создавать? Чем отличается объект от массива</summary>

Объекты - это тип данных, которые преназначены для хранения различных значений с помощью ключа и значения и выделяют следующие типы объектов - функции, массив, даты и коллекция: maps и weakmaps, sets и weaksets. В JS существует несколько способов создания объекта - это через фигурные скоба `{}`; через ключевое слово: `let user = new Person("Win")`; через object.create(): `let user = Object.create(person)`

Стоит отметить, что ключевое слово new делает несколько вещей:
- Создает новый пустой объект, который наследуется от prototype;
- К нему (объекту) привязывается значение this;
- Возвращает значение this, если в реализации не указано иноеэ

Разница между объектом и массивом

- У массивов есть методы тех, которых нет у объекта, также и наоборот
- Чтобы обратится к какому-то элементу в массиве мы должны использовать индекс от нуля. А у объекта обращение идет через точку
- Также у массива есть свойство length - делает подсчет всех элементов внутри массива.

</details>

<details>
<summary>Question: Как определить наличие свойства в объекте?</summary>

Первый и второй способ вернет булевое значение

- С помощью метод `.hasOwnProperty()`
- С помощью оператора `in`

Отличия заключается в том, что оператор in проверяет наличие свойств не только в самом объекте но и в его `ПРОТОТИПАХ`, а `hasOwnProperty` проверяет наличие свойства только в основном объекте.

- Обратится к объекту напрямую с помощью индексовой натации. Если свойство есть в объекте, то оно вернет значение, а если его нет, то undefined: `console.log(obj['prop1']); => foo`

</details>

<details>
<summary> Question: Методы объекта: key(), values(), entries(), fromEntries() </summary>

1. `Object.keys()` - возвращает массив ключей
2. `Object.values()` - возвращает массив значений
3. `Object.entries()` - возвращает массив пар ключ и значения
4. `Object.fromEntries()` - он преобразует список пар: ключ и значение в объект

```
const object1 = {
  a: 'smth',
  b: 42,
  c: false
};

console.log(Object.keys(object1));   // ["a", "b", "c"]
console.log(Object.values(object1)); // ["smth, 42, false"]
```

</details>

<details>
<summary> Question: Что такое деструктуризация? (деструктурирующее присваивание)</summary>

Деструктуризация появилась в ЕС6 и она позволяеть извлекает данные из массива или объекта с помощью определенного синтаксиса и записать их в переменную.

```
let arr = ["Ali", "Adigezalli"];
let [first, second] = arr;
console.log(first + " " + second); // * Ali Adigezalli
```

</details>

<details>
<summary> Question: Разница между Rest (остаточными параметры) и Spread (операторами расширения)?</summary>

Синтаксис одинаковый, однако задачи выполняют разные

Rest `(остаточные параметры)`. => Например у нас есть функция, и к нам приходят очень много параметров. Мы можем взять первые два параметра (a, b), а остальные параметры мы можем получить с помощью rest-оператора. Первые два параметра придут в качестве обычных значений, а рест оператор придет в виде массива

Spread `(оператор расширение)` - расширяет массив, объект. У нас есть в базе данных большой массив с пользователями и нам необходимо его скопировать и добавить пару новых пользователей и чтобы это сделать мы можем использовать spread оператор

</details>

<details>
<summary> Question:  Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? </summary>

Например у нас есть объект с большой кучей вложенностей: массивов, объектов и т.д. И когда мы хотим копировать объект через spread оператор, то копируется лишь первый уровень вложенности, а остальные не копируются. Если нам нужно использовать глубокое копирование тут есть два варианта через JSON.parse и stringify или использовать спред оператор для всех уровней вложенностей, так мы получим глубокое копирование

</details>
</details>



<details>
<summary> 6. Другое (строгий режим, всплывающие окна, ошибки, шаблонные литералые, типы таймеров) </summary>

<details>
<summary> Строгий режим (strict mode) в JavaScript?</summary>

Он появился в ЕС5, и он говорит, что наш код будет работать в строгом режиме в JS. Чтобы его использовать необходимо написать 'use strict' либо в начале скрипта либо внутри функции. Если мы его напишем в начале скрипта, то он будет иметь глобальную область видимости, а если напишем внутри функции, то будет иметь локальную область видимости. Например если мы объявим объект без переменной или продублируем параметры внутри функции

```
"use strict";
x = {p1:10, p2:20};      // This will cause an error
function x2(p1, p1) {};   // This will cause an error
```

</details>

<details>
<summary> Типы всплывающих окон в JavaScript?</summary>

`alert` - выводить информацию во всплывающем окне;

`confirm` - спрашивать соглашение во всплывающем окне; подтвердить по ОК или Отмену

`prompt` - всплывающем окно, где просят написать что-то в инпут поле

</details>

<details>
<summary> Типы ошибок в JavaScript? </summary>

1. SyntaxError - синтаксическая ошибка возникает когда мы написали неправильно какое-то слово: reutrn

2. RefferenceError - возникает когда js не может найти какую-то ссылку в которой мы пытаемся получить доступ. Например хотим определенную переменную найти а его нет

3. TypeError - возникает когда мы хотим методы определенных типов преобразовать на типов у которого этого метода нет.

</details>

<details>
<summary> Что такое шаблонные литералы (Template Literals)?</summary>

Шаблонные литаралы - это обратные кавычки, внутри обратные кавычек мы можем с помощью знака доллара и фигурными скобками (${выражение}).

</details>



<details>
<summary> Типы таймеров в JavaScript?</summary>

В JS есть два основных типа таймеров:

- `setTimeout(...)` - позволяет вызвать переданную функцию один раз через определенное время
- `setInterval(...)` - позволяет вызвать переданную функцию много раз через определенный интервал времени. Чтобы отменить `setInterval` мы можем использовать тип: `clearInterval()` и внутрь передаем переменную, где использовали `setInterval`.

</details>
</details>

---

#### 7. Переменные и функции

<details>
<summary> Правила задания имён для переменных и функций в JavaScript? </summary>

Если мы говорим задание имен переменных, то

1. Они должны содержать буквы на латинице, он должен отражать смысл того, что он хранит: `let age = 20`;

2. Цифр: `let user2 = 'Antony';`

3. Символы доллара: `let $user = 'Alice';`

4. Нижнего подчеркивания: `let _user = 'Pete';`

Если мы говорим то, что как не стоит начинать, то - первый символ не должен быть цифрой: `let 10user = 'Nick';`

Имя функции должно понятно и четко отражать что она делает и что возвращает. Функция - это действия по этому её имя
обычно является глаголом: `function checkValue() {}`

</details>

<details>
<summary> Разница между переменными: var, let и const </summary>

Существует несколько отличий между var, let и const:

1. let и const появились в ЕС6, а var был до ЕС6.

2. Переменные var можно как занова объявлять, так и повторно обновлять, что не вызовет никакой ошибки в консоле. И с этим было много проблем

3. У let мы можем присвоить новое значение, однако создавать переменную с тем же именем нельзя, а у const (если
   говорим про переменую), то мы не можем присвоить новое значение и не можем создать переменную с тем же именем. То
   есть переменная становится не изменяемой.

4. У var область видимости - глобальная или локальная (область видимости в пределах функции). У `let` и `const` - блочную область видимости, что в свою очередь означает любой элемент с фигурными скобками: функции, циклы, инструкции (if ... else). тип
</details>

<details> 
<summary> Что такое область видимости (Scope) и какие ты знаешь? </summary>

Область видимости - это место откуда мы имеем доступ к переменным или функциям. Выделяют 3 типа:

1. `Глобальная область видимости` - это когда иы объявляем переменную внутри самого файла js (внутри скрипта) не
   оборачивая ни функцией, циклом. Они доступны из любого места в коде

2. `Локальная область видимости` - переменные и функции объявленные внутри функций, доступны только внутри этой
   функции и всем вложенным в неё функциям. За ее пределами, при обращении к переменной, мы получаем ошибку

3. `Блочная область видимости` - это когда переменная доступна только внутри блока, за пределеми блока она не доступна.

</details>

<details>
<summary> Что такое необъявленная переменная и временная мертвая зона (temporal dead zone)? </summary>

1. `Необъявленная переменная` - это когда мы написали какое-то значение `a = 20` без переменных var, let либо const.
   Область видимости у необъявленных переменых - глобальная, что означает, что они доступны из любого места кода, что
   не очень хорошая практика как и var. Если мы будем использовать строгий режим, то получим ошибку ReferenceError, а в
   нестрогом undefined

2. `Временная мертвая зона` - Она появилась в ЕС6 и работает с let и const. Если мы сначало обратимся к переменной
   до ее написания, в случае с var увидем ошибку undefined, так как вар появился значительно раньше временной мертвой
   зоны. Однако если мы сначало вызовем let или const до ее написания, то получим ошибку referenceError. Из чего можно
   сделать вывод, что временная мертвая зона означает, что к переменной мы не можем обратится пока она не будет вычислена

</details>

<details>
<summary> Разница между function declaration и function expression? </summary>

Выделяют два способа объявлении функции:

- `Function Declaration` – функция, которая объявлена через кл.слово function. Например: `function multyple() {...}`

- `Function Expression` – функция, которая объявление через переменную. Например: `let multiply = function () {...}`

Отличие заключает в том, что к function declaration можно вызвать до того как объявить. Так как JS собирает все строчки
где объявляется function, а также через Hoisting (подним) их самый вверх, что позволяет нам сначало вызвать их, а потом
объявить. Еще наверное стоит отметить, что если мы объявим function expression через переменную var, то и она будет всплывать

</details>

<details>
<summary> Разница между параметром и аргументом функции? </summary>

Когда мы пишем функцию и внутри обычных скобок указываем a, b: `function value (a, b) {...}`, то это параметры.
После того как мы передали параметры мы пишем код например `return a + b`. После вызываем этой функцию через запятую,
так вот значения, которые передаются при вызове функции называются аргументами: foo (5, 7).

</details>

<details>
<summary> Как передаются параметры в функцию: по ссылке или по значению?</summary>

Примитивы передаются в функцию по значению, а объекыт и массив уже по ссылке. Стоит отметить, что когда в функции передается примитивное значение, то функция получает копию, а не примитивное знаечения, в то время как объект и массив передаются сам уже (оригинал) грубо говоря.

</details>

<details>
<summary> Разница между обычными функциями и стрелочными? </summary>

1. Синтаксис
2. У стрелочных функций нет своего this, оно берет его снаружи
3. У стрелочных функций нет arguments
4. Стрелочные функции не могут быть вызвани с new

`Что обозначает this в JavaScript?`

Это ссылка на контекст вызова функции и он динамичный, то есть, меняется от способа вызова функции

Если мы вызовем его глобально, то ссылка будет на `window` (в браузере) или `global`

Если мы напишем объекте, а затем внутри него напишем функцию, то это ссылка будет на сам объект. Однако у стрелочных функций нет своего this, и берет он ссылку из глобального контекста

`Что такое псевдомассив arguments?`

Это аргументы, которые передаются в функцию. И к нему можно обращаться как к массиву по индексу и узнать его длину, а в остальных случаях - это другой объект похожий на массив, поэтому и псевдомассив.

</details>


<details>
<summary> Разница между .call(), .apply() и bind()? </summary>

С помощью .call() - вызывает и переопределяет, через запятую аргументы
С помощью .apply() - похож на .call, только аргументы передаются внутри массива
C помощью .bind() - просто переопределяет и если байндов у нас много, то сработает только первый
</details>

<details>
<summary> Что такое IIFE (перев. Анонимная самовызывающаяся функция)? </summary>

Если нам нужно вызвать функцию не через foo(), то мы можем использовать следующий метода. По правде говоря он уже устарел,
IIFE (Immediately Invoked Function Expression) - это анонимная функцию с лексической областью видимости, которая вызывается
немедленно после его объявления. Cинтаксис: оздаёте функцию внутри круглых скобок и после закрывающей скобки, ещё ставьте
круглые скобки.

</details>

<details>
<summary> Что такое замыкание (Closure)?  </summary>

Замыкание - оно создается при написании функции со своим лексич.окружение. И когда за пределами функции есть переменная, которого внутри нашего лексического окружения нет, то он
дает доступ обращатся к этой переменной.

</details>

<details>
<summary> Что такое чистая функция? (Pure Function) </summary>

Чистая функция - это та функция, у которой нет побочных эффектов и это функция, результаты которой зависят только от входных параметров. К побочным эффектом относится

К побочным эффектам относятся:

- Запросы на сервер
- Изменения входных параметров
- Обращение к дому (квериселекторы), если говорим про JS.

Плюсы чистых функций:

- Уменьшает кол-во багов (так как он максимально низко влияет на остальную систему. Если я знаю, что у меня есть баг в функции, то он внутри него)
- Легче тестировать
- Легче понимать, посколько все что она делает заключено внутри нее и не нужно никуда бегать.

</details>

<details>
<summary> Что такое рекурсия? </summary>

Рекурсия - это функция, которая вызывает саму себя в теле этой же функции. Однако если мы не напишем условия, то цикл будет бесконечный, пока не выведится ошибка, что стек переполнен. Чтобы избежать данной ошибки необходимо условия выхода из функции. Например мы можем использовать рекурсию для вычисления чисел Фибоначчи или факториала

</details>

<details>
<summary> Что такое функции высшего порядка (Higher Order Functions)?  </summary>

HOF - обычная функция, которая принимает в качестве аргумента другую функцию, добавляет в эту функцию так скажем новый финкционал и возвращает его - это map, filter, reduce

<img src="./assets/3.PNG" alt="Primer">

</details>

<details>
<summary> Другое: синхр/ассинхрон, типы функций по способности принимать другие функции, полифил, мемоизация </summary>

<details>
<summary> Допы: разница между синхронными и асинхронными функциями?</summary>

Синхронные функции являются блокирующими, а ассинхронные нет. Когда интерпретатор натыкается на синхронную функцию, он блокирует дальнейшее выполнения операции прежде чем данная функция будет выполнения. По этому набор таких функций выполняется последовательно - одна за другой. Ассинхронные функции наоборот не блокирует дальнейшие выполнения скрипта. По этой причине различные тяжелые операции по типу запроса данных делают ассинхронными. Обычно такие функции в качестве аргумента принимают коллбек - это еще одна функции, которая выполнится как только будет выполнено асинхронная функция и которая сможет обработать полученный результат

</details>

<details>
<summary> Типы функций по способности принимать другие функции? </summary>

В JS можно выделить 3 основные типов функций в зависимости от принимаемых данных:

- Функция первого класса (first-class functions) – это функция, которая не принимает другую функцию в качестве аргумента и не возвращает функцию как значения

`const firstOrder = () => console.log( “Hello”)`

- Функции высшего порядка (HOF) – это функция, которая принимает другую функцию в качестве аргумента или возвращает функцию как значение

`const higherOrder = firstOrderReturn => firstOrderReturn()`

- Унарная функция – это функция, которая принимает только 1 аргумент, который не является функцией.

`const unaryFunction = (a) => console.log(${a} + world!)`

</details>

<details>
<summary> Что такое полифил (polyfill)? </summary>

Например у нас есть современный код написанный на ЕС6, однако он не работает в старых браузерах, так вот с пмощью полифила мы можем преобразовать наши функции для старых бразуров. Вот пример: sessionStorage доступно во всех последних браузерах (IE8 и выше), но не в IE7 и ниже. Полифилл можно использовать для включения поддержки старых браузеров, которые не предоставляют файлы sessionStorage.

</details>

<details>
<summary> Что такое мемоизация? Реализуйте базовую логику функции для мемоизации? </summary>

Это прием создании функции способность запомнить ранее вычисленное значение, а также результат. В результате при повторном вызове функции с одинаковыми аргументами она не
будет выполнена, а результат рбаоты вернется из кеша.

В программировании мемоизация — это метод оптимизации , который делает приложения более эффективными и, следовательно, более быстрыми. Он делает это, сохраняя результаты вычислений в кеше и извлекая ту же информацию из кеша в следующий раз, когда она потребуется, вместо того, чтобы вычислять ее снова.

</details>
</details>

---

#### 8. Ассинхронщина (подходы к работе: promise, callback, async/await)

<details>
<summary>Что такое коллбэк-функция (Callback)? Что такое Callback Hell?</summary>

Коллбэк-функция - это функция, которая передана в другую функцию в качестве аргумента. Например: коллбеки могут используются при обращение к Апи, когда нам необходимо дождатся ответа, и после его получения мы можем выполнить какое-то действия. Он может также использоваться в сеттаймауте вызвав функцию alert.

Стоит отметить, что есть такое понятие как callback hell, которая означает ад коллбеков, данный термин используется когда у нас внутри функции очень много коллбеков, что в свою очередь трудно читать, понимать и контролировать. Чтобы избежать его можно разделить на async и await, разделить на другие функции и вызвать их в качестве коллбека.

</details>

<details>
<summary>Что такое Promise? И расскажите про разницу между методами Promise.all(); Promise.any() и Promise.race()</summary>

Промисы - это объект и один из способов работы с асинхронным кодом и промис содержит в себе 3 состояния: `pending` - ожидания; `resolved (fulfilled)` - выполнено успешно; `rejected` - выполнено с ошибкой. Чтобы создать промис нам необходимо использовать конструкцую так называемую new Promise, которая принимает в качестве аргумента функцию, а сама функция принимает в качестве аргумента: resolve и reject.

У промисов есть методы: `Promise.all()`, `Promise.any()`, `Promise.race()`

`Promise.all()` - работает следующим образом: у нас есть много промисов, он дожидается (ждет) выполнения всех промисов. И если оно выполнется успешно, то вернет массив значений от всех промисов, которые были ему переданы. Однако если хотя бы один промис будет выполнен не успешно, то он выведет нам последний промис, который выполнен неуспешно.

`Promise.allSettled()` - работает по тому же принципу, что и `Promise.all()`, однако ему не важно выполнится ли промис успешно или с ошибкой он в любом случае выполнится.

`Promise.any()` - работает следующим образом: у нас есть списков промисов, он дожидается выполнения первого успешного промиса (кл.слово успешного) и если он находится его, то он возвращает данные результат, а если нет, то выводит ошибку

`Promise.race()` - выполнится только первый промис (не имеет разницы ошибка или успешно), остальные будут игнорировать.

</details>

<details>
<summary>Преимущества использовании промисов вместо колбэков?</summary>

- Помогает избежать коллбек-хелл, который может быть нечитаемым

- Упрощает последовательное написание последовательного читаемого ассинхроного кода с помощью then, а также обработку ошибок с помощью catch()

- Методы промисов all, allSettled, any, race

- С использованием промисов можно избежать следующих проблем: колбэк-функция была вызвана слишком рано, поздно или вовсе не была вызвана; функция была вызвана слишком мало или слишком много раз; не удалось передать необходимую среду/параметры; были пропущены ошибки/исключения.

</details>

<details>
<summary>Что такое async/await? </summary>

Способ написание ассинхроного кода, который построен на основе промисов. Он заставляет код, который работает ассинхроно, выглядить как синхронный код. Ключевое слово async возвращает всегда промис, а кл.слово await можно использовать только внутри тело функции в котором вызван async. Eсли его исп без async то выведится ошибка.

Например: частный кейс с которым я столкнулся при запросе на бэк, мне необходимо было дождаться ответа от сервера после него эвейтом получить специальный токен для захода на сервер

</details>

<details>
<summary>Что такое Eventloop (цикл событий) и как он работает?</summary>

Eventloop - это бесконечный цикл, который ожидает поступления задач, выполняет их и затем снова ждет поступления новых задач. И у него есть механизм, который называется callStack, в котором лежат как микро, так и макротаски. К микротаскам например относятся: Promise а к макротаскам относятся: setTimeout, setInterval. Стоит отметить, что сначало будут выполнятся микротаски, а затем макротаски

</details>

---

#### 9. Data structure (структура данных):

<details>
<summary>Какие структуры данных вы знаете</summary>

- `Массив и объект`

- `Map` - основное отличия заключается в том, что мы использовать в качестве ключей любой тип данных: str, true, false и т.д. Также у mapa есть свои методы и свойства, который мы можем записывать, возвращать, удалять элементы из mapa. Мы можем даже перебирать его по ключам, значением и ключом значением

- `Set` - коллекция уникальных значений внутри объекта, ключи в нем не пишутся и каждое значение встречает только 1 раз. Цикл можно сделать у него for...of

- `WeakMap` - ключи должны быть объектами.

- `Weakset`

- `Очередь` - принциа элементы добавляются в конец структуры, а извлекаются из его начала. Аналогия с магазином: первый пришел на кассу первый и вышел, а тот кто пришел последним последний и уходит (FIFO - First in first out) => shift (удаляет первый массив) и unshift (добавляет в начало массиво - элемент)

- `Стек` - элементы всегда добавляются в конец структуры и извлекаются также из конца. LIFO - Last in first out => Аналогия с бумагой: мы накладываем бумагу а если хотим его взять то берем сверху. А методы используем: push (добавляет в конец) и pop (удаляет с конца) 

</details>

#### 10. OOP and Solid

<details>
<summary>ООП</summary>

</details>


<details>
<summary>Solid</summary>

- S `(single responsobility principle)` - принцип единственной ответственный. Наши классы, функции, компоненты должны выполнять какую-то определенную одну задачу, и если он выполняет более одной задачи, то он не придерживается данного принципа. Например, если в нашем одном компоненте есть запрос на получениия данных, его фильтрация, сортировка и т.д., то он не соблюдает данный принцип. Необходимо разделять на много маленьких компонентов, где каждый будет выполнять одну определенную задачу. И если придерживаться данного принципа, то данный код легче читать, тестировать и поддерживать. 

<img src='./assets/solid/single-1.PNG' alt="Не придерживаешься принципа Single-responsibility" />
<img src='./assets/solid/single-2.PNG' alt="Придерживаться данного принципа Single-responsibility" />

- O `(open-closed principle)` - принцип открытости и закрытости. Код должен быть открыт для добавления нового функционала, при это закрыт для модификации. Другими словами вместо того, чтобы изменять существующий код, он должен быть расширен новым кодом. В классах - extends, а в реакте - композиция, где «частный» вариант компонента рендерит более «общий» и настраивает его с помощью пропсов:

</details>


1. Basic type 

- Есть примитивные типы - это string, number, boolean
- any - означает, что тип может быть любой
- unknown - он похож на any но более безопасный. 
- never

То есть например мы напишем тип и укажем ему any с 1, то при вызове его мы не получим ошибку, а в unknown/ 

2. Utility types

- Partial - делает все свойства объекта типа T необязательными.

- Required - делает все свойства объекта типа T обязательными.

- Readonly - делает все свойства объекта типа T доступными только для чтения.

- Pick - выбирает свойства объекта типа T с ключами, указанными в K.

- Exclude - У нас есть объединенный тип и он исключает какой-то обределенный тип

 объединения стилей (|)
 наследование (extend)

- Omit - у нас есть тип и нам необходимо одно из типов исключить 

3. Type/interface

- Синтаксис
- Интерфейс можно расширять
- Интерфейсы можно сливать в один общий, написав одинаковое имя, а вот тип не даст этого сделать

4. Enums - энамки юзается когда у нас есть фиксированное значение, и по сути это перечисление 

9. typeguard - когда нам необходимо защитить какой-то тип. Мы делаем проверку, что у нас элемент может быть например null. if (element) и будет тайп гвардом;

The instanceof type guard
The typeof type guard

if ('name' in person) {
      return person.name;
 }

11. generic types 

позволяют создавать компоненты, которые могут работать с различными типами данных, без необходимости повторного написания кода для каждого типа.

Обобщения представляют собой параметры типа, которые передаются в определение функции, класса или интерфейса, чтобы указать, что они должны работать с каким-то типом данных, который будет определен при использовании компонента.
```
function identity<T>(arg: T): T {
  return arg;
}

let result = identity<string>("Hello, world!");
console.log(result); // Output: Hello, world!

let numberResult = identity<number>(42);
console.log(numberResult); // Output: 42
```