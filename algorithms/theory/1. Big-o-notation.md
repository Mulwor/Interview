Big O Notation - используется для описания (оценки) сложности алгоритма. Он показывает как будет меняться производительность алгоритма в зависимости от роста входящих данных. При увеличении входящих данных будет рости две вещи - время (за которое будет отрабатывать наш алгоритм) и кол-во памяти используемых для обработки всего этих данных

Данная концепция:
- позволяет описывать скорость роста функции в зависимости от размера входных данных;
- может быть использовна для оценки эффективности алгоритма по отношению к использованию как времени (временная сложность) так и памяти (пространственная сложность);
- полезна при сравнении различных алгоритмов и их потенциальной производительности при увеличении размера входных данных;

При разработке алгоритмов важно учитывать их о-нотацию:
- позволяет получить представление о том, как алгоритмы будут вести себя при больших объемах данных.
- позволяет нам работать с приближенными математическими выражениями, опуская меньшие слагаемые. Именно это причина позволяет нам не указывать основания по тому или иному критерию


<img src="../assets/On.png" alt="Большая нотация" />

Снизу описано от самой быстрой O(1) к самому долгому O(N!) выполнение алгоритмической задачи. 


1. O(1) - константная сложность - код выполняется за одно и то же время и никак не зависит от размера входных данных. Например: прежде чем выполнится код снизу, ему необходимо сделать 100 шагов.

```
1) Пример
for(let i = 0; i < 100; i++) {...}

2) Пример
function getFirstElement(arr) { return arr[0] }
getFirstElement([1, 2, 3, 4, 5]);

3) Пример 
function isEven(number) { return number % 2 === 0 }
isEven(10);
```

2. O(log n) - логарифмическая сложность - если массив отсортирован, мы можем проверить, есть ли в нём какое-то конкретное значение, методом деления пополам. Проверим средний элемент, если он больше искомого, то отбросим вторую половину массива — там его точно нет. Если же меньше, то наоборот — отбросим начальную половину. И так будем продолжать делить пополам, в итоге проверим log n элементов. Данная сложность используется в: бинарном поиске, деревье, сортировке, криптографии, структура данных по типу heap, графы

3. O(n) - линейная сложность - время выполнения растет линейно с размером входных данных. Другими словами, чем больше входных данных (n), тем больше времени потребуется для выполнения алгоритма. Например: у нас стоит задача поиска наибольшего элемента в неотсортированном массиве. Нам придётся пройтись по всем n элементам массива, чтобы понять, какой из них максимальный.

```
1) Пример
function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i; // Найден элемент, возвращаем индекс
    }
  }
  return -1; // Элемент не найден
}
console.log(linearSearch([1, 2, 3, 4, 5, 6, 7, 8, 9], 5));
```

4. O(N*log N) -  линейно-логарифмическая сложность - чем больше данных нужно обработать, тем больше времени понадобится. Для понимания, давайте представим себе задачу сортировки книг в библиотеке. Если у вас 10 книг, сортировка может занять, скажем, 10 минут. Но если у вас 1000 книг, сортировка может занять 1000 * log(1000) минут, что означает 3000 минут. Например: быстрая сортировка или сортировка пузырьком

6. O(n2) - квадратная сложность - время выполнения алгоритма будет пропорционально квадрату размера входных данных. Например: сортировка пузырьком или сортировка выбором

7. O(2n) - экспоненциальная сложность - время выполнения алгоритма или функции растет линейно с увеличением размера входных данных, причем пропорционально удвоенному размеру данных. Например: 
```
// Упрощается до O(n)
function printNumbersTwice(n) {
  for (let i = 0; i < 2 * n; i++) {
    console.log(i);
  }
}
========================================
// Не упрощается
function printNumbersTwice(arr) {
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
  
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
}
```
В этой функции printNumbersTwice, мы используем цикл, который выполняется 2 * n раз. Это означает, что входной параметр n влияет на количество итераций цикла.


8. O(n!) - факториальная сложность - время выполнения алгоритма или функции растет факториально с увеличением размера входных данных. Факториал, обозначаемый как "n!", равен произведению всех положительных целых чисел от 1 до n. Это очень быстро растущая функция, и алгоритмы с временной сложностью "O(n!)" становятся очень неэффективными при увеличении размера входных данных. Например: перебор всех перестановок массива:

```
function generatePermutations(arr) {
  const result = [];

  function permutate(current, remaining) {
    if (remaining.length === 0) {
      result.push(current);
    } else {
      for (let i = 0; i < remaining.length; i++) {
        const newArray = [...current, remaining[i]];
        const newRemaining = [...remaining.slice(0, i), ...remaining.slice(i + 1)];
        permutate(newArray, newRemaining);
      }
    }
  }

  permutate([], arr);
  return result;
}

const inputArray = [1, 2, 3];
const permutations = generatePermutations(inputArray);
console.log(permutations);
```
