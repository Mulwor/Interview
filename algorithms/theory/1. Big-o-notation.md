Big O Notation - используется для описания (оценки) сложности алгоритма. Он показывает как будет меняться производительность алгоритма в зависимости от роста входящих данных. При увеличении входящих данных будет рости две вещи - время (за которое будет отрабатывать наш алгоритм) и кол-во памяти используемых для обработки всего этих данных

Данная концепция:
- позволяет описывать скорость роста функции в зависимости от размера входных данных;
- может быть использовна для оценки эффективности алгоритма по отношению к использованию как времени (временная сложность) так и памяти (пространственная сложность);
- полезна при сравнении различных алгоритмов и их потенциальной производительности при увеличении размера входных данных;

При разработке алгоритмов важно учитывать их о-нотацию:
- позволяет получить представление о том, как алгоритмы будут вести себя при больших объемах данных.
- позволяет нам работать с приближенными математическими выражениями, опуская меньшие слагаемые. Именно это причина позволяет нам не указывать основания по тому или иному критерию


<img src="../assets/On.png" alt="Большая нотация" />

Снизу описано от самой быстрой O(1) к самому долгому O(N!) выполнение алгоритмической задачи. 


1. O(1) - константная сложность - код выполняется за одно и то же время и никак не зависит от размера входных данных. Например: прежде чем выполнится код снизу, ему необходимо сделать 100 шагов.

```
1) Пример
for(let i = 0; i < 100; i++) {...}

2) Пример
function getFirstElement(arr) { return arr[0] }
getFirstElement([1, 2, 3, 4, 5]);

3) Пример 
function isEven(number) { return number % 2 === 0 }
isEven(10);
```

2. O(log n) - логарифмическая сложность - если массив отсортирован, мы можем проверить, есть ли в нём какое-то конкретное значение, методом деления пополам. Проверим средний элемент, если он больше искомого, то отбросим вторую половину массива — там его точно нет. Если же меньше, то наоборот — отбросим начальную половину. И так будем продолжать делить пополам, в итоге проверим log n элементов. Данная сложность используется в: бинарном поиске, деревье, сортировке, криптографии, структура данных по типу heap, графы

3. O(n) - линейная сложность - время выполнения растет линейно с размером входных данных. Другими словами, чем больше входных данных (n), тем больше времени потребуется для выполнения алгоритма. Например: у нас стоит задача поиска наибольшего элемента в неотсортированном массиве. Нам придётся пройтись по всем n элементам массива, чтобы понять, какой из них максимальный.

```
1) Пример
function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i; // Найден элемент, возвращаем индекс
    }
  }
  return -1; // Элемент не найден
}
console.log(linearSearch([1, 2, 3, 4, 5, 6, 7, 8, 9], 5));
```

4. O(N*log N) -  линейно-логарифмическая сложность - чем больше данных нужно обработать, тем больше времени понадобится. Для понимания, давайте представим себе задачу сортировки книг в библиотеке. Если у вас 10 книг, сортировка может занять, скажем, 10 минут. Но если у вас 1000 книг, сортировка может занять 1000 * log(1000) минут, что означает 3000 минут. Например: быстрая сортировка или сортировка пузырьком

6. O(n2) - квадратная сложность - время выполнения алгоритма будет пропорционально квадрату размера входных данных. Например: сортировка пузырьком или сортировка выбором

7. O(2n) - экспоненциальная сложность 

8. O(n!) - факториальная сложность
