// Регулярные выражение - способ поиска совпадений шаблона с текстом

// ! Спецсимволы
// * 1. .(точка) - любой одиночный спецсимвол. По сути означает найти шаблон b и за ним другому
// * символу. Если указать еще одну точку, то найти любым двум символам. Однако он ищет только к 
// * нижнему регистру

"hello hol hil die".match(/h.l/g)                        // ['hel', 'hol', 'hil']
"hello hol Hill die".match(/h..l/g)                      // ['hell']

// * 2. [](квадратные кавычки) - найти любой символ, который либо I большое либо i маленькое.
'it It in In Amin'.match(/[iI]/g)                        // ['i', 'I', 'i', 'I', 'i']
'it It in In Amin'.match(/[iI]t/g)                       // ['it', 'It']
// * Внутри квадратных скобок можно указать диапазон и после сразу любой другой символ. В качестве
// * диапозона могут быть и числа
'Ad bat sat sad dat'.match(/[a-d]./g)                    // ['d ', 'ba', 'at', 'ad', 'da']

// * 3. $ - если я хочу искать в конце строки. Есть также понятие экранирование - \ он необходимо
// * когда мы точку(спец.символ) хотим заменить на обычную точку. 
'Ad bat sat. sad dat.'.match(/\.$/g)                     // ['d ', 'ba', 'at', 'ad', 'da']
'Ad bat sat. sad dat'.match(/\.$/g)                      // null

// * 4. ^ - если я хочу искать в начале строки какое-то совпадение
'Ad bat sat. sad dat'.match(/^A/g)                       // ["A"]

// ? 3 и 4 пункты очень помогают в замене последнего символа. Например нам необходимо добавить в начало
// ? и в конец какой-то символ "...", то эти два метода помогут это сделать

// * Если я хочу найти в квадратных скобках слова, которые не начинаются на s, w, то мне необходимо 
// * написать следующее
'A b с w s'.match(/[^sw]/g)                                  // * ['A', ' ', 'b', ' ', 'с', ' ', ' ']
'Ad bat wiz wink swink'.match(/[^sw]../g)                    // * ['d ', 'ba', 'at', 'ad', 'da']

// * 4. \d  - обозначает любую единичную цифру. 
'5 4 3 2 1'.match(/\d/g)                                     // * ['5', '4', '3', '2', '1']
'5 4 3 211'.match(/\d/g)                                     // * ['5', '4', '3', '2', '1', '1']
'5 4 3 211'.match(/\d\d\d/g)                                 // * ['211']
'5 4 3 11'.match(/[0-9][0-9]/g)                              // * ['11']

// * 5. \D - все что угодно, кроме цифры
'5 ba 11'.match(/\D/g)                                       // * [' ', 'b', 'a', ' ']

// * 6. \s - позволяет искать пробелы. Например хочется найти слова заканчивающиеся на en и пробел
'nos nes sen sun kes'.match(/en\s/g)                         // * ['en ']

// * 7. \S - все кроме пробела

// * 8. \w - ищет любую букву - (запятые и пробелы не входят сюда) и \W - все, кроме букв  
'nose, nos'.match(/\w/g)                                     // *  ['n', 'o', 's', 'e', 'n', 'o', 's']
'nose, nos'.match(/\W/g)                                     // *  [',', ' ']

// * 9. \b - граница слова; \B - не границ
'asi, mosa, is, kimaylayf'.match(/\b\w\w\b/gi)               // * ['11'] => здесь все 2 буквы 
'asif'.match(/\B\w\B/gi)                                     // * ['s', 'i'] => нет границ между буквами

// ! Квантификация нужна для сокращения ввода всех спецсимволов
// * 1. n{*} - сколько раз должен элемент повторятся. Можно также через запятую указать сколько будет
// * искать вхождений
'5 4 3 211'.match(/\d\d\d/g)                                 // * ['211']
'5 4 3 211'.match(/\d{3}/g)                                  // * ['211']
'5 4 3 21 211'.match(/\d{2,3}/g)                             // * ['21', '211']

// * 2. *(звездочка) - от 0 и до скольки угодно выше. В начале ищет первый символ,
// * затем второй
'bn ben been black book'.match(/be*/g)                       // * ['b', 'be', 'bee', 'b', 'b']

// * 3. +(плюс) - ищет от 1 и выше
'xx xax xaax xaaax xbx'.match(/xa+x/g);                      // ? ===>  ['xax', 'xaax', 'xaaax']

// * 3. ?(вопрос) - ищет либо 0 либо 1
'x x x'.match(/x?/g);                                        // ? ===>   ['x', '', 'x', '', 'x', '']



// Пример №1 - Использование карты
"4444 4545 8545 8545".match(/\d\d\d\d \d\d\d\d \d\d\d\d \d\d\d\d/g)   // ? ===> ['4444 4545 8545 8545']
"4444 4545 8545 8545".match(/\d{4} \d{4} \d{4} \d{4}/g)               // ? ===> ['4444 4545 8545 8545']
"4444 4545 8545 8545".match(/\d{4}\s\d{4}\s\d{4}\s\d{4}/g)            // ? ===> ['4444 4545 8545 8545']

// Пример №2 - Пользователь может ввести через пробел, а может через дефис
"4444 4545 4444-4545".match(/\d{4} \d{4}/g)                           // ? ['4444 4545']  
"4444 4545 4444-4545".match(/\d{4}-\d{4}/g)                           // ? ['4444-4545']
"4444 4545 4444-4545".match(/\d{4}(\s|-)\d{4}/g)                      // ? ['4444 4545', '4444-4545']
"+38 (050)".match(/^\+38\s\(\d{3}\)/g)                                // ? ['+38 (050)']
"(050)"

"hello@ua.ua hello@primer hello@bk hello@bk.ru @bk.ru".match(/\w+@\w+\.\w/g)  //  ['hello@ua.u', 'hello@bk.r']

// ? (...) - повторения действует на несколько символов. если что-то стоит в группирующих скобках
// ? и сразу после ')' стоит оператор повторения - он подействует на все, что стоит внутри скобок.
'xabx xababx xaabbx'.replace(/x(ab)+x/g, '!');             // ? ===> '! ! xaabbx'
'ab abab abab abababab abea'.replace(/(ab)/g, "!")         // ? ===> '! !! !! !!!! !ea'
