ООП

1. Основные принципы ООП?

Полиморфизм - способность функции работать с различными типами данных. Например есть функция, которые может принимать разные типы данных: string и number, но функция одна.

2. Что такое SOLID?

- S (single-responsibility) - каждый метод (класс, модель) в объект должен отвечать за свою задачу (одну задачу); 
- O (open-closed) - можно дополнять объект путем добавлени; 
- L (liskov substitution) => (Принцип подстановки Барбары Лисков) => 
- I (Interface Segregation) => (Принцип разделения интерфейсов) => когда нам необходимо разбить один больше интерфейс на много маленьких.
- D (Dependency Inversion) => (Принцип инверсии зависимостей) =>  

3. Разница между классовым и прототипным наследованием?
4. Что такое функциональное программирование?
5. Разница между функцией и методом?
7. Плюсы и минусы ФП и ООП?
8. Что такое дескрипторы свойств объектов?
9. Что такое статический метод класса (static)? Как осуществляется его вызов?
10. Разница между композицией и наследованием?


Solid - аббревиатура из 5 принципов (правил, ограничений или набор каких-то действий) => ULBI__TV

S => `Single responsibility` (принцип единственной ответственности) => 1 класс (сущность, функция) должен решать 1 задачу. Когда наша сущность сильно разрастается, решает много задач, то мы получаем много связанного кода, что-то ломается одно, ломается и все другое. Также ухудшается читаебольность данного кода, если у нас класс на пару тысяч кодов, то с этим классом явно что-то не так. Вносить изменения - это долго и дорого.

O => `Open-closed principle` (принцип открытости и закрытости) => програмные сущности (классы, функции) должны быть открыты для расширения, но закрытые для изменения. Если мы хотим добавить расширение то можно использовать например в классах - наследование. Однако изменять существующий работающий код - плохо по одной простой причине, что он уже протестирован работает и с ним проблем нет, если все таки изменяем код то необходимо исп тест и убеждатся в том, что мы ничего не сломали. 

L => `Liskov substitution` (принцип подстановки Барбары Лисков) => сущности (классы, функции), которые использует родительский тип должны точно также работать с дочерними классами, при этом ничего не должно ломатся в логике программы и она не должна нарушаться. Наследуемый класс должен дополнять, а не замещать поведение базового класса, при работе с дочерними классами мы должны быть уверены, что у нас ничего не сломается

I => `Interface segregation` (принцип разделения интерфейса) => програмные сущности не должны зависеть от методов, которые они не используют. Основная суть заключается в том, чтобы разбивать наши толстые интерфейсы наши програмные сущности на более маленькие узкоспециализированные решающие одну задачи. Нельзя заставлять клиента реализовывать интерфейс, которым он не пользуется.

D => `Dependency inversion` (принцип инверсии зависимостей) => модули высокого уровня не должны зависеть от модулей более низкого уровня, все они должны зависеть от абстракций, а они в свою очередь не должны зависеть от деталей, а детали как раз должны зависеть от абстракции. 

У нас есть завод, внутри завода есть станки, работники, электричество = они между собой связаны, в свою очередь станки также могут иметь детали: скажем наручник №1, крутилка №007. Представим себе что одна из деталей сломалось, мы меняем эту деталь в станке и оказывается, что логика работы станка меняется. Наши работники с этим станком теперь работать не могут, или для другой детали нужна будет более мощное электричество и здесь как раз происходит принцип инверсии зависимостей. У нас модули высокого уровня зависят от модулей низкого уровня. Чтобы этого избежать - можно исп так называемый трансформатор (некая абстракция), который сам подберет напряжения



Data structure - Структура данных 

`Массив` - содержит в себе в основном список однотипных элементов. И мы можем взаимодействовать со всем масивом либо с кокретным индексом массива. Мы можем находить элементы в массиве, удалять, изменять, добавлять и т.д.

`Объект` - структура данных где описываем какой-либо либо один объект: человек. У него есть имя, фамилия, возраст, гражданство и т.д.

`Set` - похож на объект, но каждое значение уникальное, то есть встречается всего 1 раз. Чтобы создать set мы используем new Set(), чтобы добавить значение используем set.add; чтобы удалимть .delete и т.д. Перебирается set через for...of и  фороф

`Map` - похож на объект, но ключ может выступать в качестве любого типа. У него есть методы и свойства. Например, через new Map() мы можем создать коллекцию, через set - записываем ключ и значения; через get возвращает значения с помощью ключа; через has - возвращает true, если ключ есть. А также мы можем использовать перебор для map через key, values, entries 

`WeakMap и WeakSet` - они должны быть объектами, а не примитивными значениями. WeakMap не поддерживает перебор и у него есть только: get, set, delete, has, однако в weakset есть только add, has, delete

`Очередь` - структура данных состоящих из каких-то элементов. Основной принцип - это то, что элементы добавляются в конец структуры, а извлекаются из его начала. Аналогия с магазином: первый пришел на кассу первый и вышел, а тот кто пришел последним последний и уходит (FIFO - First in first out) => shift (удаляет первый массив) и unshift (добавляет в начало массиво - элемент)

`Стек` - элементы всегда добавляются в конец структуры и извлекаются также из конца. LIFO - Last in first out => Аналогия с бумагой: мы накладываем бумагу а если хотим его взять то берем сверху. А методы используем: push (добавляет в конец) и pop (удаляет с конца) 

Стоит отметить, что pop и push выполняются быстро, а методы shift и unshift медленно