#### I. Типы данных

<details>
<summary> 1. Перечислите типы данных в JavaScript? </summary>
В JavaScript существует 8 типов данных, их можно разделить на примитивные и ссылочные. К примитивным относятся следующие типы:

- `string` (строка),

- `number` (число),

- `biginit`,

- `boolean`,

- `symbol` (уникальный идентификатор) - необходимо для создания уникальных id, чтобы создать его необходимо написать функцию Symbol(""). Если сравнить два одниковых символа между собой, они никогда не равны

- `null`,

- `undefined`

А к ссылочному относится:

- `object`. А определить тип данных можно с помощью typeOf.

<details>
<summary>Question: В чем отличие между null и undefined?</summary>

Стоит отметить, что разница между null и undefined в том, что `Undefined` - это когда переменная объявлена, но мы ей не присвоенно значение, а `null` - когда мы присвоили значение специально, и как бы говорим, что у нас есть переменная и она пустая.

</details>

</details>

<details>
<summary>Question: К какому типы данных относится массив и функция и чем они похожи?</summary>
Это все объект.
</details>

<details>
<summary> Question: В чем смысл объекта? И когда мы сравниваем объект, то что мы сравнимаем? </summary>
В нем можно хранить данные с помощью ключ и значения. Когда мы сравниваем объект, то мы сравниваем ссылки на объект
</details>

</details>

<details>
<summary>Question: Как превратить любой тип данных в булевое? Как преобразовать тип данных в булевой?</summary>

В JS мы можем явно преобразовать типы, всего их три: String(), Boolean(), Number() - и все они являются функциями.

Чтобы превартить тип данных в булевый можно использовать:

1. Функцию Boolean(null)
2. !! (Два логических не)

Чтобы превратить тип данных в числовое можно использовать:

1. Функцию Number('5')
2. метод parseInt("5")

Что превратить тип данных в строку можно использовать:

1. Функцию String(null)
2. Или через метод Object.prototype.toString(43)
</details>

<details>
<summary>Question: Перечислите все ложные значение? Перечислите falsy</summary>

Falsy - это следующие значение: "", 0, null, undefined, NaN, false. А все остальное уже true

</details>

<details>
<summary>Question: Что такое NaN? Как определить, что значение равно NaN?</summary>

NaN расшифровывается как not-a-number, что означает не является числом. Мы получаем его когда выполняем математическую операцию неправильно. Например, если мы возьмем строку и какое-то число, то оно нам даст NaN. А его особенностью можно выделить то, что она не равна ничему даже самому себе как в строгом, так и в нестрогом сравнении. Для того, чтобы проверить, что число не является числом использует функцию isNaN()

</details>

<details>
<summary>Question: разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?</summary>

Неявное преобразование происходит автоматически путем арифмитические действий, а явное когда мы указываем тип специально через функции Number или ParseInt, функцию String или метод toString, Boolean или двойное логическое !!

</details>

<details>
<summary>Question: JavaScript статически, или динамически типизированный язык? </summary>

Динамически типизированный язык, так как происходит автоматическое преобразование типов

</details>

</details>

---

#### II. Операторы

<details>
<summary> 2. Какие операторы вы знаете? </summary>

I. Арифмитические операторы:

- сложения,
- вычитания,
- умножения,
- делание,
- возведение в стене `**`
- взятия от остатка `%`

II. Логические операторы:

- Или (||) - возвращает true, если одно из значений верно
- И (&&) - возвращает true только в том случае, если оба значеные верны, а вернет он последнее значение. Однако если все таки одно из значений false, то дальше он не пойдет.
- ! (Логическое не) - меняет значение на противоположное, стоит упомянуть также про

К особенностям стоит отметить, что есть также приоритетность, но если мы обернем в скобки то данная приоритетность уже не будет иметь разницы.

III. Операторы сравнения:

- больше, меньше, меньше или равно, больше или равно,
- нестрогое (==) и строгое равенство (===),
- не равно (!=).
</details>

<details>
<summary>Question: Чем отличается строгое равенство от нестрогового?</summary>

Строгое равенство отличается от нестрогого тем, что нестрогое сравнивает только значения без приведения типов, а строгая сравнивает и значения и типы

</details>

<details>
<summary>Question: Что такое двойное логическое не !!</summary>

Он нужен для преобразований значений к булевому значению.

Допилить идею: Если мы применим его к строке, то оно сначало станет булевое, а после этого к ней применится логическое отрицание.

</details>

<details>
<summary>Question: Что такое оператор нулевого слияние ??</summary>

Он возвращает значение правого операнда, если левый операнд содержит null или undefined, в противном случае возвращается значение левого операнда. Он похож на или, так как он возвращает правый операнд если в левом хранится ложное значение, а не только null / undefined

</details>

---

#### III. Циклы и инструкции

<details>
<summary>Что такое выражения (expression) и инструкции (statement) в JavaScript?</summary>

I. Выражение - это арифмитическое действие. Например:`+, -, *, /, %, >, =, ==, i++, --i`, Math.random - случайное число.

II. Инструкция - это фрагмент кода, который выполняет определенное действие. К инструкциям относятся: `if, if-else, while, for, for..in, for..of switch, for-in, объявления переменных`

</details>

<details>
<summary>Что такое switch/case? Правила использования switch/case?</summary>

Инструкция switch() сравнивает выражение со случаями или кейсами, перечисленными внутри нее а затем выполняет соответствующие инструкции. Внутри case описывается логика и в конце добавляется break для прекращение проверок, если одна из них сработало, в конце указывает дефолт когда не один из кейсов не отработал.

Правила:

1. Условия должно быть число или строка
2. Не допускается дублирования значений
3. Инструкция дефолт является опциональная
4. Если не для одного не найдено совпадение выполняется блок default
5. Break используется для остановки цикла, если мы его не укажем то цикл продолжится
</details>

<details>
<summary> Какие есть и как работают циклы в JS? </summary>

Цикл - это когда нам необходимо какое-то действие повторить несколько раз

- for (let i=..; i > str; i++)
- for ... in
- for ... of

- While... — сначала проверяет условия, а потом их выполняет, и так по кругу. Цикл будет повторятся пока условия верно
- Do...while — сначала выполняет условия, а потом их проверяет, и так по кругу.

</details>

<details>
<summary>В чем отличие между циклом for...in и for...of</summary>

for ... in - для перебора объекта, и если мы используем его в массиве, то переберутся только ключи в массиве.
for ... of - для перебора массива, перебираются как значения так и ключи

</details>


---

#### IV. Методы в JavaSciprt

<details>
<summary>Number method: min, max, random, round, floor, ceil, trunc</summary>

1. Как получить минимальное число? - Math.min();
2. Как получить максимальное число? - Math.mix();
3. Как сгенерировать случайное число в JavaScript? => Math.random();
4. Как округлить число в ближайшему целому? => Math.round(); 
5. Как округлить число в меньшую степень? => Math.floor();
6. Как округлить число в большую степень? => Math.ceil();
7. Как удалить числа после точки? => Math.trunc();

</details>

<details>
<summary>String method: padStart, padEnd, trim, startsWith, endsWith, replaceAll </summary>

Они нужны для того, чтобы дополнять строку до нужного размер. Оба принимаются два аргументе: `длина (число)` и символ (строка), которая будет заполнять оставщуюся длину. Если его не указать, то он будет в видепустой строки

1. `String.prototype.padStart()` => подставляет дополнительные символы перед началом строки (слева)
2. `String.prototype.padEnd()` => подставляет дополнительные символы перед концом строки (справа)
3. `String.prototype.trim()` => удаляет пробельные символы как в начале так и в конце строки

Данные методы определяются начинается или заканчивается ли строка требуемыми символами, тем самым помогают определить соответствие в начале и в конце. Принимают два аргумент: `символы`, которые будут искаться в строке и второй `число`, с которого начнется поиск. 

Методы строк: .startsWith() и .endsWith() проверяют начинается-ли (заканчивается) строка с определенным  символом. 
4. `String.prototype.startsWith()` => начинается ли строка с данного метода
5. `String.prototype.endsWith()` => заканчивается ли строка с данным словом. 

6. `String.prototype.replaceAll()` => у нас есть одно строковое предложение и мы хотим в этой предложенние заменить все слова на другие. Например: у кошки была кошка по имени Мушка, мы хотим кошку заменить на утку. Получается у утки была утка по имени Мушка. 


</details>

<details>
<summary>Array method: isArray; slice and splice; find, findIndex, indexOf</summary>

1. `Array.isArray()` => проверяет является ли значение массивом

2. `Array.prototype.slice()` - возвращает новый массив с выбраннами элементами (индексами) со стораго массив. Он принимает необязательные аргументы в виде начало индекса и конец его, по которому будуться извлекаться данные. Однако стоит упомянуть, что индексы могут быть и отрицательными, а это значит, что они будут извлекаться с конца. Если мы ничего не укажем то он вернет новый массив со старыми элементе. 

3. `Array.prototype.splice()` - нужен для удаления или добавления в или из массива. Аргументы: начальный индекс по которому начнется изменения массива, если укажем отрицательный индекс, то работу начнет с конца. И два необязательных аргумента: какое кол-во необходимо удалить элемментов в массиве и что добавить к массиву элемент

Следующие методы нужны для поиска в массиве. Они (find, findIndex) принимают в качестве аргумента функцию, только indexOf принимает в качестве аргумента обычное значение
4. `Array.prototype.find()` - вернёт первый найденный в массиве элемент, который подходит под условие.

5. `Array.prototype.findIndex()` - возвращает индекс первого найденного в массиве элемента, который подходит под условие, в противном случае -1 вернет

6. `Array.prototype.indexOf()` -  вернётся индекс первого найденного элемента или -1, если ничего не нашлось



Следующие методы необходимы для перебора массива, они проверяются соответствует ли условия переданных в функции, после чего возвращают полученный результат в виде булеан. 

7. `Array.prototype.some()` - перебирает массив и смотрит соответвствует ли один конкретный элемент в массиве логическому условию.

8. `Array.prototype.every()` -  перебирает массив и смотрит соответвствует ли все элементы в массиве логическому условию.

```
[2, 5, 8, 1, 4].some(elem => elem > 10);                // false
[12, 5, 8, 1, 4].some(elem => elem > 10);               // true
[12, 5, 8, 130, 44].every(elem => elem >= 10);          // false
[12, 54, 18, 130, 44].every(elem => elem >= 10);        // true
```

9. `Array.prototype.forEach()` и `Array.prototype.map()` => отличие заключается в том, что forEach() меняет исходный массив, а map возвращает новый. Еще одним отличиям является то, что если мы используем .map, то мы можем использовать
и другие методы. 


10. `Array.prototype.includes()` - определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false.

11. Array.prototype.push() -
12. Array.prototype.pop() -
13. Array.prototype.shift() -
14. Array.prototype.unshift() -

15. Array.prototype.flat() - 
16. Array.prototype.flatMaP() - 






</details>



<details>
<summary> Назовите способы преобразования массива в объект?  </summary>
</details>


</details>


---

#### Другое (пусть будет навсякий пожарный)

<details>
<summary> 1. Строгий режим (strict mode) в JavaScript?</summary>

Он появился в ЕС5, и он говорит, что наш код будет работать в строгом режиме в JS. Чтобы его использовать необходимо написать 'use strict' либо в начале скрипта либо внутри функции. Если мы его напишем в начале скрипта, то он будет иметь глобальную область видимости, а если напишем внутри функции, то будет иметь локальную область видимости. Например если мы объявим объект без переменной или продублируем параметры внутри функции

```
"use strict";
x = {p1:10, p2:20};      // This will cause an error
function x2(p1, p1) {};   // This will cause an error
```

</details>

<details>
<summary> 2. Типы всплывающих окон в JavaScript?</summary>

`alert` - выводить информацию во всплывающем окне;

`confirm` - спрашивать соглашение во всплывающем окне; подтвердить по ОК или Отмену

`prompt` - всплывающем окно, где просят написать что-то в инпут поле

</details>

<details>
<summary> 3. Типы ошибок в JavaScript? </summary>

1. SyntaxError - синтаксическая ошибка возникает когда мы написали неправильно какое-то слово: reutrn

2. RefferenceError - возникает когда js не может найти какую-то ссылку в которой мы пытаемся получить доступ. Например хотим определенную переменную найти а его нет

3. TypeError - возникает когда мы хотим методы определенных типов преобразовать на типов у которого этого метода нет.

</details>



<details>
<summary> 4. Что такое шаблонные литералы (Template Literals)?</summary>

Шаблонные литаралы - это обратные кавычки, внутри обратные кавычек мы можем с помощью знака доллара и фигурными скобками (${выражение}).
</details>
---
