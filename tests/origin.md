#### V. Переменные и функции

<details>
<summary> Правила задания имён для переменных и функций в JavaScript? </summary>

Имя переменной должны содержать, буквы, цифры или символы доллара и нижнего подчеркивания
Первый символ не должен быть цифрой. 

Имя функции должно понятно и четко отражать что она делает и что возвращает. Функция - это действия по этому её имя обычно является глаголом
</details>

<details>
<summary> Разница между переменными: var, let и const</summary>

Существует несколько отличий между var, let и const
1. let и const появились в EC6. А var был с самого начала. На вопрос почему пришли новые переменные можно ответить так, что возникли ошибки связанные с варом. Мы можем с одним и тем же именем объявить переменную вас 
и обновить данную переменную. И решили немного разграничить
2. У let мы можем присвоить новое значение, однако создавать новую переменную с тем же именем нельзя, а у const Нельзя присвоить новое значение и нельзя создавать новую переменную с тем же именем
3. Еще одним отличием является область видимости: у var - это функциональная и глобальная. У let и const блочная область видимости. 
4. Cтоит отметить, что var всплывает. Когда происходит парсинг чтение кода, он дает значение undefined, а у let и const он не всплывает и если мы вызовем его до того как укажем переменную то выведет ошибку: ReferenceError. Так называемая временная мертвая зона

</details>

<details>
<summary>Что такое необъявленная переменная и временная мертвая зона? </summary>

Стоит отметить, что есть такое понятие как необъявленная переменная - это когда мы написали значение: `var a = 20` без `var`.  Необъявленные переменные имеют глобальной области видимости, что означает, что они способны быть видимым в любом месте кода. В строгом режиме он выдаст ошибку ReferenceError, в нестрогом undefined.

Есть также понятие как временная мертвая зона - по сути она означает, что мы 
сначало вызвали переменную а затем к ней обратились, если мы вызываем var, то получаешь ответ undefined, если let и const вызвали, то получили ошибку ReferenceError

</details>


<details> 
<summary>Что такое область видимости (Scope)</summary>


Функциональная область видимости - переменные и функции объявленные внутри функций, доступны только этой функции и всем вложенным в неё функциям. За ее пределами при обращении к переменной мы получаем ошибку

Блочная область видимости - это когда переменная доступна только внутри блока, за пределеми блока не выйдет

Глобальная область видимости - определяется на уровне скрипта.

Стоит отметить, что область видимости – набор правил по которым происходит поиск переменных. Сначала переменная ищется в локальной области видимости, если её нет, то поиск происходит во внешней области видимости и так далее пока не дойдет до глобальной.
</details>


<details>
<summary> Что такое поднятие (Hoisting)? </summary>

Hoisting представляет процесс доступа к переменным до их определения. Компиляция кода происходит в два прохода:

1. При первом проходе компилятор получает все объявления переменных, все идентификаторы. При этом никакой код не выполняется, методы не вызываются.
2. При втором проходе собственно происходит выполнение. <br/>

А это значит, что переменные объявленые через var, а также Function Declaration (объявлении функции через function) можно получить доступ еще до объявление значение. Они могут спокойно идти в конце документа, а обращаться к ним мы можем в любом месте JS.<br/>

```
console.log(foo);       // undefined
var foo = "Tom";


display();
function display(){
    console.log("Hello Hoisting");
}
```

let, const, function expression не сплывают и вместо undefined мы получим ошибку referenceError, так как к ним не присваивается начальное значение и обратится к ним раньше приведет лишь к ошибке <br/>

```
console.log(foo);   // Uncaught ReferenceError: Cannot access 'foo' before initialization
let foo = "Tom";
console.log(foo);   // не будет выполняться
```



</details>



<details>
<summary>Что такое полифил (polyfill)? </summary>

</details>

<details>
<summary> Разница между function declaration и function expression?  </summary>

</details>

<details>
<summary> Что такое замыкание (Closure)?  </summary>

</details>


<details>
<summary>  Что обозначает this в JavaScript? </summary>

</details>


<details>
<summary> Что такое функции высшего порядка (Higher Order Functions)?  </summary>

</details>


<details>
<summary> Что такое чистая функция? </summary>

</details>


<details>
<summary> Разница между .call(), .apply() и bind()? </summary>

</details>

<details>
<summary> Почему в JS функции называют объектами первого класса? </summary>

</details>

<details>
<summary> Что такое IIFE? </summary>

</details>

<details>
<summary>Что такое мемоизация? Реализуйте базовую логику функции для мемоизации?</summary>

</details>


<details>
<summary>Как передаются параметры в функцию: по ссылке или по значению?</summary>

</details>

<details>
<summary> Что такое рекурсия? </summary>
</details>

<details>
<summary>Типы функций по способности принимать другие функции?  </summary>
</details>


<details>
<summary> Разница между параметром и аргументом функции? </summary>
</details>

<details>
<summary> Разница между синхронными и асинхронными функциями? </summary>
</details>

<details>
<summary>  Разница между обычными функциями и стрелочными? </summary>
</details>


#### VI. Eventloop and Promise

1. Типы таймеров в JavaScript?
2. Что такое цикл событий (event loop) и как он работает?
3. Что такое AJAX? Плюсы и минусы использовании Ajax?
4. Подходы при работе с асинхронным кодом?
5. Преимущества использовании промисов вместо колбэков?
6. Что такое коллбэк-функция (Callback)? Что такое Callback Hell?
7. Что такое async/await?
8. Разница между Promise.all(), Promise.any() и Promise.race()?