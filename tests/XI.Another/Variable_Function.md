#### V. Переменные и функции

<details>
<summary> 1. Правила задания имён для переменных и функций в JavaScript? </summary>

Если мы говорим задание имен переменных, то 

1. Они должны содержать буквы на латинице, он должен отражать смысл того, что он хранит: `let age = 20`;

2. Цифр: `let user2 = 'Antony';`

3. Символы доллара: `let $user = 'Alice';`

4. Нижнего подчеркивания: `let _user = 'Pete';`


Если мы говорим то, что как не стоит начинать, то - первый символ не должен быть цифрой: `let 10user = 'Nick';`          

Имя функции должно понятно и четко отражать что она делает и что возвращает. Функция - это действия по этому её имя 
обычно является глаголом: `function checkValue() {}`

</details>

<details>
<summary> 2. Разница между переменными: var, let и const </summary>

Существует несколько отличий между var, let и const:

1. let и const появились в ЕС6, а var был до ЕС6. 

2. Переменные var можно как занова объявлять, так и повторно обновлять, что не вызовет никакой ошибки в консоле. 
И с этим было много проблем 

3. У let мы можем присвоить новое значение, однако создавать переменную с тем же именем нельзя, а у const (если 
говорим про переменую), то мы не можем присвоить новое значение и не можем создать переменную с тем же именем. То 
есть переменная становится не изменяемой. 

4. У var область видимости - глобальная или локальная (область видимости в пределах функции). У `let` и `const` -
блочную область видимости, что в свою очередь означает любой элемент с фигурными скобками: функции, циклы, инструкции
(if ... else).

</details>

<details> 
<summary> 3. Что такое область видимости (Scope) и какие ты знаешь? </summary>

Область видимости - это место откуда мы имеем доступ к переменным или функциям. Выделяют 3 типа: 

1. `Глобальная область видимости` - это когда иы объявляем переменную внутри самого файла js (внутри скрипта) не 
оборачивая ни функцией, циклом. Они доступны из любого места в коде

2. `Локальная область видимости` - переменные и функции объявленные внутри функций, доступны только внутри этой 
функции и всем вложенным в неё функциям. За ее пределами, при обращении к переменной, мы получаем ошибку

3. `Блочная область видимости` - это когда переменная доступна только внутри блока, за пределеми блока она не доступна.

</details>

<details>
<summary> 4. Что такое необъявленная переменная и временная мертвая зона (temporal dead zone)? </summary>

1. `Необъявленная переменная` - это когда мы написали какое-то значение `a = 20` без переменных var, let либо const. 
Область видимости у необъявленных переменых - глобальная, что означает, что они доступны из любого места кода, что 
не очень хорошая практика как и var. Если мы будем использовать строгий режим, то получим ошибку ReferenceError, а в 
нестрогом undefined


2. `Временная мертвая зона` - Она появилась в ЕС6 и работает с let и const. Если мы сначало обратимся к переменной
до ее написания, в случае с var увидем ошибку undefined, так как вар появился значительно раньше временной мертвой 
зоны. Однако если мы сначало вызовем let или const до ее написания, то получим ошибку referenceError. Из чего можно 
сделать вывод, что временная мертвая зона означает, что к переменной мы не можем обратится пока она не будет вычислена

</details> 

<details>
<summary> 5. Разница между function declaration и function expression? </summary>

Выделяют два способа объявлении функции:

- `Function Declaration` – функция, которая объявлена через кл.слово function. Например: `function multyple() {...}`

- `Function Expression` – функция, которая объявление через переменную. Например: `let multiply = function () {...}`

Отличие заключает в том, что к function declaration можно вызвать до того как объявить. Так как JS собирает все строчки 
где объявляется function, а также через Hoisting (подним) их самый вверх, что позволяет нам сначало вызвать их, а потом
объявить. Еще наверное стоит отметить, что если мы объявим function expression через переменную var, то и она будет всплывать

</details>


<details>
<summary> 6. Разница между параметром и аргументом функции? </summary> 

Когда мы пишем функцию и внутри обычных скобок указываем a, b: `function value (a, b) {...}`, то это параметры. 
После того как мы передали параметры мы пишем код например `return a + b`. После вызываем этой функцию через запятую, 
так вот значения, которые передаются при вызове функции называются аргументами: foo (5, 7).  

</details>


<details>
<summary> 7. Как передаются параметры в функцию: по ссылке или по значению?</summary>

Примитивы передаются в функцию по значению, а объекыт и массив уже по ссылке. Стоит отметить, что когда в функции передается 
примитивное значение, то функция получает копию, а не примитивное знаечения, в то время как объект и массив передаются сам уже
 (оригинал) грубо говоря.  

</details>


<details>
<summary> 8. Что такое IIFE (перев. Анонимная самовызывающаяся функция)? </summary>

Если нам нужно вызвать функцию не через foo(), то мы можем использовать следующий метода. По правде говоря он уже устарел,
IIFE (Immediately Invoked Function Expression) - это анонимная функцию с лексической областью видимости, которая вызывается 
немедленно после его объявления. Cинтаксис: оздаёте функцию внутри круглых скобок и после закрывающей скобки, ещё ставьте 
круглые скобки.

</details>

---

<details>
<summary> 9.  Что такое замыкание (Closure)?  </summary>

Замыкание - оно создается при написании функции со своим лексич.окружение. И когда за пределами функции есть переменная, которого внутри нашего лексического окружения нет, то он
дает доступ обращатся к этой переменной.

</details>


<details>
<summary> Что такое чистая функция? </summary>

</details>


<details>
<summary> Что такое рекурсия? </summary>

Рекурсия  - это функция, которая вызывает саму себя в теле этой же функции. Однако если мы не напишем условия, то цикл будет бесконечный, пока не выведится ошибка, что стек переполнен. Чтобы избежать данной ошибки необходимо условия выхода из функции. Например мы можем использовать рекурсию для вычисления чисел Фибоначчи или факториала

</details>


---


<details>
<summary> Что такое полифил (polyfill)? </summary>

</details>

<details>
<summary>  Что обозначает this в JavaScript? </summary>

</details>


<details>
<summary> Что такое функции высшего порядка (Higher Order Functions)?  </summary>

HOF - обычная функция, которая принимает в качестве аргумента другую функцию, добавляет в эту функцию так скажем новый финкционал и возвращает его - это map, filter, reduce

<img src="../../assets/3.PNG" alt="Primer">

</details>


<details>
<summary> Разница между .call(), .apply() и bind()? </summary>

</details>

<details>
<summary> Почему в JS функции называют объектами первого класса? </summary>

</details>


<details>
<summary> Что такое мемоизация? Реализуйте базовую логику функции для мемоизации? </summary>

</details>


<details>
<summary> Типы функций по способности принимать другие функции?  </summary>
</details>


<details>
<summary> Разница между синхронными и асинхронными функциями? </summary>
</details>

<details>
<summary> Разница между обычными функциями и стрелочными? </summary>
</details>


#### VI. Eventloop and Promise

1. Типы таймеров в JavaScript?
2. Что такое цикл событий (event loop) и как он работает?
3. Что такое AJAX? Плюсы и минусы использовании Ajax?
4. Подходы при работе с асинхронным кодом?
5. Преимущества использовании промисов вместо колбэков?
6. Что такое коллбэк-функция (Callback)? Что такое Callback Hell?
7. Что такое async/await?
8. Разница между Promise.all(), Promise.any() и Promise.race()?

