<details>
<summary>  Типы таймеров в JavaScript? Имеется ввиду: setTimeOut и setTimeInterval </summary>

setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

</details>

<details> 
<summary> Чем отличается детерминированность от депонтность? </summary>

Детермининрованнность - при одинаковых параметрах возвращает одинаковые входные данные. Депонтность - предпологаем предсказуемый результат.

</details>

<details>
<summary>Что такое DOM? </summary>

Расшифровывает как document object model - объектная модель документа. Он нужен для того,
что

Можем ли мы отрисовать html-документ в браузере не имея дома?

Как называется события которое свидетельствует о том, что наш дом полностью загружен? -
domContentLoaded

</details>

<details>
<summary>Можем ли мы отрисовать html-документ в браузере не имея дома?</summary>

</details>

<details>
<summary>Как называется события которое свидетельствует о том, что наш дом полностью загружен?</summary>

domContentLoaded

</details>

<details>
<summary>Что такое handshake?</summary>

</details>

<details>
<summary>Что делает оператор instanceOf и чем он отличается от typeOf</summary>

typeOf - возвращает тип в виде строки
instanceOf принадлежит жи данный экземпляр к классу или его предку: true / false

</details>

<details>
<summary>Что такое оператор new?</summary>

Ключевое слово необходимо для создания инстансов конструктора. У классов может быть много конструкторов.

</details>

<details>
<summary> Что такое boxing/unboxing?</summary>

Преобразование из примитиво в объект (boxing), а из объекта в примитив уже unboxing. В момент вызова функции будет упаковка - это буде объект, который возмет по прототипу

</details>

Иной собес:

JSON.stringify() =>
JSON.parse() =>
Какие способы есть копировать (клонирование) объекта
Object.assign =>
Что такое глубокое копирование =>
Сложность алгоритма =>
Что такое this =>

### Function
--

</details>

<details>
<summary> 9. Что такое анонимная функция? </summary>

Анонимная функция - это функция у которого нет имени после function. Однако если мы обратится через стрелочную функцию и присвоим ей имя, то она будет уже именная фукнция и обратится к нему можно будет через имя. Также можно его вызвать через метод объекта. Можно его также вызвать по клику через addEventListener

```
const myFunc = function () {
    console.log('Hello')
}
myFunc()
```

```
const user = {
    name: 'Alex',
    age: 25,
    greet: function () {
        console.log("hi")
    }
}
user.greet()
```

```
document.getElementById("btn").addEventListener("click", function () {
    console.log("Вы кликнули по кнопке")
})
```

</details>

<details>

<summary>10. Что такое функции высшего порядка (Higher Order Functions)?</summary>

Функции высшего порядка – принимает в качестве аргумента функцию, добавляет в нее новый функционал и возвращает новую функцию, но уже с новым функционалом. К функциям высшего порядка относятся: map, filter, reduce.
<img src = "./assets/3.PNG" alt="Пример">

</details>

<details>
<summary> 11. Типы функций по способности принимать другие функции? </summary>

В JS можно выделить 3 основные типов функций в зависимости от принимаемых данных:

- Функция первого класса (first-class functions) – это функция, которая не принимает другую функцию в качестве аргумента и не возвращает функцию как значения

`const firstOrder = () => console.log( “Hello”)`

- Функции высшего порядка (HOF) – это функция, которая принимает другую функцию в качестве аргумента или возвращает функцию как значение

`const higherOrder = firstOrderReturn => firstOrderReturn()`

- Унарная функция – это функция, которая принимает только 1 аргумент, который не является функцией.

`const unaryFunction = (a) => console.log(${a} + world!)`

</details>

<details>
<summary> 12. Что такое чистая функция? </summary>

Чистая функция – функция, которая всегда возвращает один и тот же результат в зависимости от этого параметра без побочных эффектов. К побочным эффектам относятся: http-запросы и запросы DOM (квериселектор); изменения в файловой системе; видоизменения входных параметров.

К побочным эффектам относятся:

- Запросы на сервер
- Изменения входных параметров
- Обращение к дому (квериселекторы), если говорим про JS.

```
* Чистая функция *
function calculateGST( productPrice ) {  return productPrice * 0.05;  }
const add = (x, y) => x + y;            add (4, 4);

* Нечистая функция *
let tax = 20;
function calculateGST( productPrice ) { return productPrice * (tax / 100) + productPrice;}
tax = 24
Зависит от внешней переменной и при передаче одного и того же аргумента поттенциально может возвращать разные результаты.

```

Плюсы чистых функций:

- Уменьшает кол-во багов (так как он максимально низко влияет на остальную систему. Если я знаю, что у меня есть баг в функции, то он внутри него)
- Легче тестировать
- Легче понимать, посколько все что она делает заключено внутри нее и не нужно никуда бегать.

</details>

<details>
<summary>14. Что такое коллбэк-функция (Callback)? Что такое Callback Hell?
</summary>

Колбэк-функция (или обратный вызов) - это функция, которая переданна в другую функцию в качестве аргумента.

Используется коллбеки например при обращении к API, когда мы вынуждены ждать ответа, и только после его получения можем выполнять какие-то действия.

Он позволяют разработчику быть уверенным в том, что какой-либо фрагмент кода не начнет выполняться, пока не закончит свое исполнение другой фрагмент кода.

```
function doHomework(subject, alertFinished) {
  alert(`Starting my ${subject} homework.`);
  alertFinished();
}

function alertFinished(){
  alert('Finished my homework');
}

doHomework('math', alertFinished);
```

Callback hell - когда вложенность большая, что его трудно читать контролировать. Чтобы избежать его можно написать: async/await, разделить на маленькие элементы (функции) и вызывать его в качестве коллбеке

</details>

<details>
<summary>15. Что такое мемоизация? Реализуйте базовую логику функции для мемоизации
</summary>

Мемоизация - метод, который пытается повысить производительность путем кеширование (сохранение) ее раннее вычисленных результатов. Он нужен для предотвращение повторных вычислений, если у нас есть одинаковые аргументы, она не будет выполнена, а результат работы вернется из кеша. Существует минус данного подхода: нужно выделять доп.память

```
const memoize = (fn) => {
	const cache = {}
	return function (param) {
		if(cache[param]) {
			return cache[param]
		} else {
			const result = fn(param);
			cache[param] = result;
			return result;
		}
	}
}

const toUpper = (str = " ") => str.tuUpperCase();
const toUpperMemorized = memoize(toUpper)

toUpperMemoized("Yauhen")			// Call function 'toUpper' get result
toUpperMemoized("Yauhen")			// Doesn't call 'toUpper; return result from 'cache'
```

</details>

<details>
<summary>16. Что такое цикл событий (event loop) и как он работает?  </summary>

Стоит начать с того, что JS - однопоточный язык, в текущий момент времени может выполняться только 1 задача. А если она слишком ресурсозатратная, то мы не сможем приступить к следующей пока не выполнется это задача.

Как в однопоточном JS выполнять код асинхронно? - В этом нам помогает такая вещь как event loop. Eventloop - бесконечный цикл, который ожидает задачи, выполняет их и затем снова ожидает поступления новых задач. Но есть такая как стек-вызов. Стек-вызовов - операции всегда попадают на вершину стека и с этой же вершины они выполняются.

Сначала выполняется secondFunction(), затем выполняется console.log(3) и сразу же уходить из стека. Затем туда попадает firstFunction, выполняется console.log(1) и сразу же уходить из стекаm, выполняется console.log(2) и сразу же уходить из стека. Затем firstFunction выполняет результат и уходит из стека и затем секондФанкшн выполняет результат и уходит из стека

<img src = "./assets/1.PNG" alt = "stack">
<img src = "./assets/2.PNG" alt = "stack2">

Стоит отметить, что может так случиться, что задача поступает, когда движок занят чем-то другим (выполняет скрипт, или может истечь таймре), тогда она ставится в очередь.

- Основной поток выполняются в начале
- Микрозадачи - это промисы и очередь на рендер - выполняются по середине.
- Макрозадачи - браузерность Апи или манипуляция с дом-деревом. К нему односится setTimeOut. Выполняются в конце

```
setTimeout(function timeout() {                // 4
	console.log('Таймаут');
}, 0);

let p = new Promise(function(resolve, reject) {  //1
	console.log('Создание промиса');
	resolve();
});

p.then(function(){								// 3
	console.log('Обработка промиса');
});

console.log('Конец скрипта');				// 2

```

</details>

---

### Promise; ajax, async, await

<details>
<summary> Что такое промисы (Promises)? </summary>
Промисы - это один из способов работы с асинхронным кодом в JavaScript без написания слишком большого количества обратных вызовов.

Содержит в себе 3 состояния: `pending` - ожидания; `resolved` - выполнено успешно; `rejected` - выполнено с ошибкой.

Объект Promise создаётся при помощи ключевого слова new и своего конструктора. Конструктор Promise принимает в качестве аргумента функцию. Эта функция должна принимать две функции-колбэка в качестве параметров: resolve (если операция завершится успешно) и reject (если операция не удастся, то вернет ошибку)

```
const myFirstPromise = new Promise((resolve, reject) => {
  // выполняется асинхронная операция, которая в итоге вызовет:
  // resolve(someValue); // успешное завершение
  // reject("failure reason"); // неудача
});
```

</details>

<details>
<summary> Разница между Promise.all(), Promise.allSettled(), Promise.any(), Promise.race()? </summary>

`Promise.all()` - ждет когда все промисы выполняться и вернет массив с результатом. Если один из промисов вернет ошибку, то остальные промисы будут игнорироваться

`Promise.allSettled()` - ждёт выполнения всех промисов, при этом неважно, завершились они успешно или с ошибкой. Он особенно удобен, когда запросы независимы и ошибка в одном не влияет на другие, так как Promise.allSettled() дождётся завершения всех запросов. Если же запросы зависимы, то лучше использовать метод Promise.all().

`Promise.any()` - ждет когда выполнится первый успешный промис (без ошибки), он становится результатом, а остальные будут игнорироваться. Если ни один из промисов не завершится успешно , AggregateError становится ошибкой Promise.any

`Promise.race()` - выполнится первый промис, остальные будут игнорировать. Стоит отметить, что не важно выполнится ли успешно промис или с ошибкой. Его используют, чтобы запустить несколько промисов и дождаться того, который выполнится быстрее.

</details>

<details>
<summary> Преимущества использовании промисов вместо колбэков? </summary>

1. Помогает избежать коллбек-хелл, который может быть нечитаемым
2. Упрощает последовательное написание последовательного читаемого ассинхроного кода с помощью then, а также обработку ошибок с помощью catch()
3. Упрощает написание паралельного ассинхроного кода с помощью Promise.all
4. С использованием промисов можно избежать следующих проблем: колбэк-функция была вызвана слишком рано, поздно или вовсе не была вызвана; функция была вызвана слишком мало или слишком много раз; не удалось передать необходимую среду/параметры; были пропущены ошибки/исключения.
</details>

<details>
    <summary> Что такое async/await? </summary>
</details>

<details>
    <summary> Что такое AJAX?</summary>
</details>

<details>
    <summary> Плюсы и минусы использовании Ajax? Подходы при работе с асинхронным кодом?</summary>
</details>

<details>
    <summary> Какие приемы работы с асинхронным кодом в JS Вы знаете?</summary>
</details>

<details>
	<summary>  Как клиент взаимодействует с сервером? </summary>
</details>

#### Разница между обычными функциями и стрелочными функциями

1. Синтаксис
2. У стрелочных функций нет своего this, оно берет его снаружи
3. У стрелочных функций нет arguments
4. Стрелочные функции не могут быть вызвани с new

#### Что такое функция первого рода?

Это когда мы можем передать функцию в объект

#### Чистая функция

Принимает какие-то параметры и всегда возвращает ожидаемый результат в зависимости от параметра. У чистых функций не должны быть никаких side-effectoв. Если мы не можем предсказать результат то это уже нечистая функция

---

#### Что такое контекст в функциях? (Что обозначает this в JavaScript?)

Контекст определяет как функция была вызвана, что указывает на ключевое слово this в текущем участки кода

#### Как мы можем изменить контекст?

С помощью .call() - вызывает сразу функцию, первым параметром принимает контексте к которому необходимо привязать функию и через запятую передаю аргументы
С помощью .apply() - похож на .call только аргументы передаются внутри массива
C помощью .bind() - возвращает новую функцию привязанную в контекст, которую мы передали параметром.

---

#### EventLoop

Eventloop работает на движке JS, который занимается тем что разгребает микро и макротаски,
другими словами работает с ассинхронным кодом. Что касается синхроных операций, они попадают сразу в колл-стек и евентлуп занимается именно тем когда к нему приходит что либо и кладется в очередь, то он смотрит когда закончился call-стек, он приходит в очередь забирает от туда таск сначала разбирается с микротаска (когда очередь опустеет он идет к микро) а затем с макротасками и кладет их в стек

#### Ассинхронный и синхронный


<details>
<summary> Что такое ECMAScript? В чём отличие от JavaScript? </summary>

ECMAscript - спецификация языка программирование, в котором содержатся правила, сведения и рекомендации, которые
должны соблюдаться скриптовым языки , чтобы он считался совместивым с EcmaScript. А JS одна из версий скриптового языка. EcmaScript6

</details>

<details>
<summary> Что такое регулярное выражение (Regular Expression)? Какие методы используются в регулярных выражениях? </summary>

С помощью регулярок можно найти и заменить текст.

</details>

#### 7. Чем отличаются друг от друга унарный, бинарный и тернарный оператор. 
Унарный - когда один аргумент у нас есть, бинарный когда два аргумента, а тернарный когда у нас есть три аргумента

К бинарному оператору можно отнесты: остаток от деление (%), + (сложение) - (вычитание)
К унарному оператору: инкремент (++), декремент (--)







