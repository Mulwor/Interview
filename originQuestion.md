<details>
<summary> 1. Что такое реакт? </summary>
Это javascript - библиотека с открытым исходным кодом разработанной фейсбуком, которая используется для создания пользовательских интерфейсов, особенно для создания одностраничных приложений
</details>

<details>
<summary> 2. Какие основные особенности реакта? </summary>

- Реакт использует виртуальный дом вместо реального, так как он учитывает, что взаимодействия с реальном домом - дорогостоющая;
- Создает и переиспользует компоненты в разных местах
- Поддерживает рендеринг на стороне сервера.
- Следует однонаправленному потоку данных или привязке данных.

</details>

<details>
<summary> 3. Что такое jsx?  </summary>

Это JSX — расширение языка синтаксиса JavaScript. Используется он для описания того, как должен выглядить пользовательский интерфейс. По сутиэто синтаксический сахар между createElement() и HTML.

К основным качествам: облегчает понимание, повышает производительность, должен иметь один самый внешний элемент

</details>

<details>
<summary> 4. В чем разница между элементом и компонентом? 
</summary>

Элемент - простой объект и описывает то, что мы хотим увидеть на экране. Они иммутабельны, то есть они не могут быть изменены после создания.

```
const element = <h1>Привет, мир</h1>;
```

Компонент - это маленькие, повторно используемые части кода, которые возвращают React-элементы для отображения на странице.
Его можно объявит через классовый подход
с методом render(), который наследуется из React.Component. Или он может быть функцией. В обоих случаях, он принимает пропсы на вход и возвращает дерево JSX в качестве вывода:

```
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}
```

</details>

<details>
<summary> 5. Как создавать компоненты в реакте?</summary>

Существует два способа объявленние компонентов:

- Функциональные компоненты - которые на вход получает данные в виде пропсов и возвращает реакт-элементы. Представляет собой функции

```
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}
```

- Классовые компоненты - создаются через классы.

```
class Welcome extends React.Component {
  render() {
    return <h1>Привет, {this.props.name}</h1>;
  }
}
```

</details>

<details>
<summary> 6. Когда использовать компонент класса вместо функционального компонента? </summary>

Когда компоненты необходимы методы состояния или жизненого цикла использется классы. А если нам это не нужно то используетм компоненты функций.

Однако с добавлением хуков мы можем использовать состояния, жизненные циклы и другие функции в функциональном компоненте

</details>

<details>
<summary> 7. Что такое чистые компоненты? (React.PureComponent) </summary>

В React.PureComponent реализован метод жизненного цикла shouldComponentUpdate(), отвечающий за проверку, нужно ли производить перерисовку компонента или нет. Он производит поверхностное сравнение пропсов и состояния компонента с предыдущими, чтобы понять, изменились ли они, и перерисовка происходит только в случае нахождения различий.

В React.Component перерисовка происходит всегда, так как подобная проверка отсутствует. Однако при желании ее может реализовать программист.

В функциональных компонентах за это отвечает React.memo()

</details>

<details>
<summary> 8. Что такое стейт (состояние) в реакте</summary>

Состояние компонента (state) — это объект, в котором хранится необходимая компоненту информация, пока он существует. Важно, что состояние контролируется только самим компонентом, другие компоненты не имеют к нему доступа, если только не передать данные из состояния через пропы дочерним компонентам. Состояние может меняться, при этом происходит перерисовка компонента.

Менять состояния можно через хук useState

</details>

<details>
<summary> 9. Что такое пропсы в реакте </summary>

Пропы (props) — это свойства, которые передаются в компонент. Пропы были созданы, чтобы обеспечить передачу данных от родительского компонента к дочернему.

</details>

<details>
<summary> 10. В чем отличие между стейтом и пропсом?</summary>

Пропсы передаются компоненту как параметры функции, тогда как state находится внутри компонента (по аналогии с переменными, которые объявлены внутри функции).

</details>

<details>
<summary> 11. Почему нам нельзя объявить состояние напрявую? </summary>

Если вы попытаетесь обновить состояние напрямую, компонент не будет повторно отображаться.

Вместо этого используйте setState()метод. Он планирует обновление объекта состояния компонента. Когда состояние изменяется, компонент отвечает повторным рендерингом.

</details>

<details>
<summary> 12. В чем разница между обработкой событий HTML и React?</summary>

- В HTML имя события обычно пишется строчными буквами по соглашению: `<button onclick="activateLasers()"></button>`. В то время как в React следует соглашению camelCase :
  `<button onClick={activateLasers}>`

- В HTML мы можем вернуться false, чтобы предотвратить поведение по умолчанию:
  `<a
  href="#"
  onclick='console.log("The link was clicked."); return false;'
/>`. В то время как в React вы должны вызывать preventDefault() явно:

```
function handleClick(event) {
  event.preventDefault();
  console.log("The link was clicked.");
}
```

</details>

<details>
<summary> 13. Как передать параметры обработчику событий (event handler) или обратному вызову (callback-function)? </summary>

1. Если мы говорим про компонент, то через пропсы к дочерним компонентам можно передавать функцию

2. Чтобы передать параметры обработчику событий можно обернуть в стрелочную функцию. Это действие равносильно использованию .bind:

```
<button onClick={() => this.handleClick(id)} />
```

```
<button onClick={this.handleClick.bind(this, id)} />
```

</details>

<details>
<summary> 14. Что такое SyntheticEvents в Реакте? </summary>

`SyntheticEvents` - это кроссбраузерная обёртка над нативным экземпляром события. Его API такой же, как и собственное событие браузера, включая stopPropagation()и preventDefault(), за исключением того, что события работают одинаково во всех браузерах.

</details>

<details>
<summary> 15. Что такое встроенные условные выражения (inline conditional expressions)?</summary>

Вы можете использовать операторы if или тернарные выражения , доступные в JS, для условного отображения выражений. Помимо этих подходов, вы также можете встроить любые выражения в JSX, заключив их в фигурные скобки, а затем логический оператор JS &&.

```
<h1>Hello!</h1>;
{
  messages.length > 0 && !isLogin ? (
    <h2>You have {messages.length} unread messages.</h2>
  ) : (
    <h2>You don't have unread messages.</h2>
  );
}
```

</details>

<details>
<summary> 16. Что такое ключевое свойство (key) prop и в чем преимущество его использования в массивах элементов?</summary>

A key— это специальный строковый атрибут, который следует включать при создании массивов элементов. Key prop помогает React определить, какие элементы были изменены, добавлены или удалены. Чаще всего в качестве ключа мы используем ID

`const todoItems = todos.map((todo) => <li key={todo.id}>{todo.text}</li>);`

В крайнем случае если нет id, то можно использовать индекс

</details>

<details>
<summary> 17. В чем пользов рефов (refs)? </summary>

В основном нам надо избегать рефов, однако они могут быть полезны когда нам нужен прямой достук к элементу DOM или к экземпляру компоненту

</details>

<details>
<summary> 18. Как создавать рефы (refs)? </summary>

Создаются с помощью метода `React.createRef()` и прикрепляются к элементам React через ref атрибут.

</details>

<details>
<summary> 19. Что такое React.forwardRef</summary>

`React.forwardRef` - функция, которая позволяет передать рефы в качестве пропсов дочерному компоненту.

```
const ButtonElement = React.forwardRef((props, ref) => (
  <button ref={ref} className="CustomButton">
    {props.children}
  </button>
));

// Create ref to the DOM button:
const ref = React.createRef();
<ButtonElement ref={ref}>{"Forward Ref"}</ButtonElement>;
```

</details>

<details>
<summary> 20. Что такое виртуальный дом и как он работает? </summary>

Виртуальный дом - копия реального дома, которая хранится в памяти и в дальнейшем синхронизируется с настоящим домом при помощи библиотеки: Reactdom в App.

По поводу его работы, то всего 3 простых шага:

1. Когда происходит изменения каких-то данных, весь пользовательский интерфейс повторно отображается в представлении Virtual DOM.
2. После устанавливается разница между виртуальным домом и новом
3. И как только это установка будет выполнена, реальный дом изменится

</details>

<details>
<summary> 21. Какая разница между теневым домом и виртуальным домом? </summary>

Они оба отвечают за скорость загрузки страницы, а также создают отдельный экземпляр реального дома, однако отличия их в том, что:

- Virtual-dom создает копию всего объекта DOM, в отличии от shadow-dom, которое создает небольшие фрагменты объекта DOM

- Virtual-dom пытается избегать любых ненужных и дорогостоящих изменения в DOM. Он объединяет несколько изменений и выполняет один повторный рендеринг вместо множества мелких. Он добавляет поддерево элементов DOM в визуализацию документа вместо того, чтобы добавлять его в дерево DOM основного документа.

- Shadow-dom полезен для области видимости CSS. Он гарантирует, что стили, созданные внутри одного элемента Shadow DOM, остаются изолированными и находятся в пределах своей области.

- Shadow-dom реализует браузеры, а virtual-dom: библиотеки Реакт и вью
</details>

<details>
<summary> Что такое React Fiber? Какова его цель? </summary>
Относительно новый механизм, который был положен в основу реакта, начиная с 16 версии. Основной задачей было увеличить производительность для анимации, лейотов, а также раставлять приоритеты. Это и в то же время является его особенность, а именно инкрементальный рендиринг: когда можно разделить работу рендеринга на куски распределить их по нескольким фреймам. 
</details>

<details>
<summary> Что такое контролируемые и не контролируемые компоненты? </summary>

Контролируем компоненты - элементы, которые контролирует реакт, и туда входят следующие теги: input, textarea, select. Для того чтобы сделать управляемый компонент, нужно чтобы значение этих элементов хранилось именно в состоянии React компонента, т.е. управлялось через setState/useState, таким образом состояние React-компонента становится единственным источником правды для этих элементов.

Это неуправляемые компоненты - они хранят свои данные прямо в DOM. Чтобы прочитать их значения, используются рефы.

</details>

<details>
<summary> В чем разница между createElement и cloneElement? </summary>

- createElement - Создаёт и возвращает новый React-элемент определённого типа. Код, написанный с использованием JSX, будет преобразован в React.createElement()
- cloneElement - Клонирует и возвращает новый React-элемент, используя элемент в качестве отправной точки (передачи с помощью пропсов)

</details>

<details>
<summary> Что такое поднятие состояния в верх в React? </summary>
Это паттерн, которое с помощью одного состояние может быть использовано сразу для несколько компонентов. Обычно некоторые компоненты должны реагировать на одни и те же события или изменения состояния, поэтому необходимо каким-то образом уведомлять все компоненты когда что-то изменилось как раз и используется состояние поднятие вверх. Это означает что общее состояние должно быть поднятно до общего ближайшего предка
</details>

<details>
<summary> Назовите стадии (фазы) жизненного цикла (lifecycle) компонента? </summary>

Жизненный цикл компонента состоит из трех отдельных фаз жизненного цикла:

- Moundting (монтирование) => компонент готов к монтированию в DOM браузера. Методы: constructor(), getDerivedStateFromProps(), render()и componentDidMount()жизненного цикла.
- Updating (обновление) => компонент обновляется при изменении его состояния через hook useState или передача пропcов.
- Unmounting (размонтирование) => на последнем этапе компонент не нужен и размонтируется из DOM браузера
</details>

<details>
<summary> 34 Каковы методы жизненного цикла React? </summary>

1. shouldComponentUpdate() - когда нам необходимо указать следующий рендер на основе изменений состояния и пропсов. Он вызывает перед рендером, когда получает новые пропсы или состояние
2. static getDerivedStateFromProps() - вызывается непосредственно перед вызовом метода render. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять. Он необходим когда состояние зависит от изменений в просах
3. getSnapshotBeforeUpdate() - вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет компоненту брать некоторую информацию из DOM перед её возможным изменением.
4. static getDerivedStateFromError() и componentDidCatch() - вызывается после возникновения ошибки у компонента-потомка.
</details>

<details>
<summary> 35 Что такое компоненты высшего порядка? </summary>

Компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент. Она смотрит на входящие пропсы и принимает на их основании решение : перерисовывать или не перерисовывать.
</details>


<details>
<summary>  37 Что такое контекст? </summary>
</details>

Он разработан для передачи данных от одного компонента к другой избегая промежуточные компоненты. Например: избегая пропс дриблинга. Чтобы создать контекст нужно написать React.createContext(), затем используя provider мы оборачиваем наш компонент, в нем мы также задать значения, а чтобы получить доступ необходимо обернуть в Consumer()
</details>

<details>
<summary> 38.  Что такое props.children? </summary>

Это контент между открывающим и закрывающим тегом компонента. Например: `<Welcome>Привет, мир!</Welcome>` Для классовых компонентов используйте this.props.children:

</details>


<details>
<summary>

</summary>
</details>


<details>
<summary>

</summary>
</details>



День №1:
46	What are fragments? Why fragments are better than container divs? Что такое фрагменты? / Почему фрагменты лучше контейнеров?
48	What are portals in React? => Что такое порталы в React?
49	What are stateful/stateless components? => Что такое компоненты без состояния / компоненты с отслеживанием состояния?
50. Каковы приимущество и недостатки реакта?
51. Что такое предохранетили error boundary?
52. What is the purpose of render method of react-dom? - Какова цель рендеринга реакт-дом
53. Что такое ReactDOMServer?
What is the impact of indexes as keys? - Как влияют индексы на ключи?
54. Как использовать декораторы в реакте
55. How do you conditionally render components? =- Как условно визуализировать компоненты
68	Why we need to be careful when spreading props on DOM elements?
How you implement Server-Side Rendering or SSR?

День №2:
1. What is a switching component? - Что такое switching компоненты
2. What is strict mode in React? - Что такое strict mode в реакте
3. What are React Mixins? - Что такое реакт-миксины
4. Why should component names start with capital letter? - Почему компоненты должны начинаться с заглавной буквы
5. How to loop inside JSX? - Как сделать цикл внутри jsx
6. What is the difference between React and ReactDOM? - В чем отличие между реакт и реакт-дом
98	How to use React label element? - Как использовать Реакт-лэйбл элеменит
101 - В чем разница между setState и replaceState method
103 - What is the recommended approach of removing an array element in react state? - Как удалить элемент из массива
128 - What are render props? - Что такое рендер пропс
