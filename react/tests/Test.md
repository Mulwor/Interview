### In addition to the main сoncept (lyfecycle, hooks, hoc and another)

<details>
<summary>1. Расскажите про методы жизненные циклы компонента, и что в них входят (имеется ввиду какие методы исп внутри каждого цикла)?</summary>

У компонента есть три метода жизненного цикла: 
- mounting (монтирование) - это рождения компонета, это процесс создания компонента и его добавления в DOM;
- update (обновления) - можно сравнить с ростом и то что компонент живет;
- unmounting (размонтирование) - это уже смерть человека;

Существует разные методы жизненого цикла, которые реакт предоставляет на разных этапах жизненого цикла компонента. Жизненный цикл делится на 4 части: инициализация, монтаж, обновления и размонтирования. 

- За инициализацию отвечает конструктор;

- За монтаж отвечает определенные методы: конструктор, рендер, но больше хочется обратить внимания сomponentDidMount() - метод, который вызывается после того, как компонент был добавлен в DOM

- За обновления отвчает: shouldComponentUpdate(), вызывается перед повторным рендерингом компонента и если нет никаких изменений, то он предотвратит повторный рендеринг, а если есть то он вызовет рендерит и вызовет метод componentDidUpdate, что означает, что компонент обновился;

- За размонтирования отвечает componentWillUnmount(), вызывает перед удаление компонента, что означает конец жизненного цикла компонента

В хуках за все это отвечает хук useEffect;

</details>

<details>
<summary> 2. Что такое хуки и расскажите про преимущество и недостатки хуков? </summary>

Хуки появились в 16 версией и используется они в функциональном компоненте. Хуки представляют из себя функции, c помощью которых мы можем подписаться на какое-то состояние, сохранять его а потом обновлять данное состояние (useState). Также мы можем делать запросы на сервер с помощью, работать с контекстом и много другое

К премуществам хуков относится: 

- Переход с классовых компонентах на функциональный. Поясню: раньше чтобы сделать какое-то дефолтное состояние необходимо было написать 6-7 строк кода сейчас это можно заменить одним юзстейтом
- Его легче читать
- Также с помощью одного хука useEffect можно описать жизненный цикл компонента хотя в классах нам необходимо было использовать componentDidMount(), componentWillUnmount() 

К недостатком относится: 

- Мы не можем исп хуки в классах
- Проблема с пропс дриблингом, у нас есть для этого хука useContect(), но у него есть ряд проблем. Легче использовать стейт-менеджмент

</details>


<details>
<summary> 3. Расскажите про основные хуки: useState(), useEffect(), useContect()? </summary>

1. Хук `useState()` -  это функция, которая меняет состояние. Хук `useState('')` принимает начального значение, которая пишется внутри фигурных скобок и возвращает массива с 2 параметрами - первый параметр это тукущая состояние, а вторым является функция, которая обновляет состояние: `[state, setState]`. 

```
const [state, setState] = React.useState('')
```

2. Хук `useEffect()` - необходим нам для выполнения каких-то side-effect (побочных эффектов), там запрос на сервер, setTimeOut (setInterval), обращения к дому и т.д.

#### Дополнительный вопрос: Когда срабатывает useEffect? - Юзэффект срабатывает после того как отрисовался наш компонент. А также: 

- Если мы не написали никакую зависимость, то он будет вызываться всегда;
- Если мы передали какую-то зависимость, то он срабатывается при первом рендеринге и когда меняется состояние. 
- А если мы написали зависимость но не передали ничего, то срабатывает только при монтирования компонента

#### Дополнительный вопрос: Что такое функция очистки useEffect и как очистить useEffect? 

Одна из функций хука позволяет нам останавливать побочные эффекты, которые больше не нужно выполнять, до того, как наш компонент будет размонтирован. Нам нужно просто написать return внутри useEffect

```
useEffect(() => { 
    // the side effect takes place here. 
        return () => { 
            // the cleanup function 
        } 
}, [])
```

3. Хук `useContect()`

</details>


<details>
<summary> 4. Расскажите про дополнительные хуки: useReducer(), useCallback(), useRef()? </summary>

</details>


<details>
<summary> 5. Что такое компонент высшего порядка? </summary>

</details>

<details>
<summary> 6. Разница между memo и useMemo? </summary>

</details>

<details>
<summary> 7. Что такое поднятие состояния в вверх в React?</summary>

</details>


<details>
<summary> 8. Что такое предохранители (Error Boundaries)?</summary>

</details>


