#### React

##### Основы

<details>
<summary> В чем разница между обработкой событий HTML и React?</summary>

- В HTML имя события обычно пишется строчными буквами по соглашению: `<button onclick="activateLasers()"></button>`. В то время как в React следует соглашению camelCase :
  `<button onClick={activateLasers}>`

- В HTML мы можем вернуться false, чтобы предотвратить поведение по умолчанию:
  `<a
  href="#"
  onclick='console.log("The link was clicked."); return false;'
/>`. В то время как в React вы должны вызывать preventDefault() явно:

```
function handleClick(event) {
  event.preventDefault();
  console.log("The link was clicked.");
}
```

</details>

<details>
<summary> Как передать параметры обработчику событий (event handler) или обратному вызову (callback-function)? </summary>

1. Если мы говорим про компонент, то через пропсы к дочерним компонентам можно передавать функцию

2. Чтобы передать параметры обработчику событий можно обернуть в стрелочную функцию. Это действие равносильно использованию .bind:

```
<button onClick={() => this.handleClick(id)} />
```

```
<button onClick={this.handleClick.bind(this, id)} />
```

</details>

<details>
<summary> Что такое SyntheticEvents (синтетические события) в Реакте? </summary>

`SyntheticEvents` - это кроссбраузерная обёртка над нативным экземпляром события. Его API такой же, как и собственное событие браузера, включая stopPropagation()и preventDefault(), за исключением того, что события работают одинаково во всех браузерах.

</details>

<details>
<summary> Что такое встроенные условные выражения (inline conditional expressions)?</summary>

Вы можете использовать операторы if или тернарные выражения , доступные в JS, для условного отображения выражений. Помимо этих подходов, вы также можете встроить любые выражения в JSX, заключив их в фигурные скобки, а затем логический оператор JS &&.

```
<h1>Hello!</h1>;
{
  messages.length > 0 && !isLogin ? (
    <h2>You have {messages.length} unread messages.</h2>
  ) : (
    <h2>You don't have unread messages.</h2>
  );
}
```

</details>



<details>
<summary> В чем пользов рефов (refs)? Как создавать рефы (refs)? </summary>

В основном нам надо избегать рефов, однако они могут быть полезны когда нам нужен прямой достук к элементу DOM или к экземпляру компоненту

Создаются с помощью метода `React.createRef()` и прикрепляются к элементам React через ref атрибут.

</details>

<details>
<summary> Что такое React.forwardRef</summary>

`React.forwardRef` - функция, которая позволяет передать рефы в качестве пропсов дочерному компоненту.

```
const ButtonElement = React.forwardRef((props, ref) => (
  <button ref={ref} className="CustomButton">
    {props.children}
  </button>
));

// Create ref to the DOM button:
const ref = React.createRef();
<ButtonElement ref={ref}>{"Forward Ref"}</ButtonElement>;
```

</details>

<details>
<summary> Какая разница между теневым домом и виртуальным домом? </summary>

Они оба отвечают за скорость загрузки страницы, а также создают отдельный экземпляр реального дома, однако отличия их в том, что:

- Virtual-dom создает копию всего объекта DOM, в отличии от shadow-dom, которое создает небольшие фрагменты объекта DOM

- Virtual-dom пытается избегать любых ненужных и дорогостоящих изменения в DOM. Он объединяет несколько изменений и выполняет один повторный рендеринг вместо множества мелких. Он добавляет поддерево элементов DOM в визуализацию документа вместо того, чтобы добавлять его в дерево DOM основного документа.

- Shadow-dom полезен для области видимости CSS. Он гарантирует, что стили, созданные внутри одного элемента Shadow DOM, остаются изолированными и находятся в пределах своей области.

- Shadow-dom реализует браузеры, а virtual-dom: библиотеки Реакт и вью
</details>

<details>
<summary> Что такое React Fiber? Какова его цель? </summary>
Относительно новый механизм, который был положен в основу реакта, начиная с 16 версии. Основной задачей было увеличить производительность для анимации, лейотов, а также раставлять приоритеты. Это и в то же время является его особенность, а именно инкрементальный рендиринг: когда можно разделить работу рендеринга на куски распределить их по нескольким фреймам. 
</details>

<details>
<summary> Что такое контролируемые и не контролируемые компоненты? </summary>

Контролируем компоненты - элементы, которые контролирует реакт, и туда входят следующие теги: input, textarea, select. Для того чтобы сделать управляемый компонент, нужно чтобы значение этих элементов хранилось именно в состоянии React компонента, т.е. управлялось через setState/useState, таким образом состояние React-компонента становится единственным источником правды для этих элементов.

Это неуправляемые компоненты - они хранят свои данные прямо в DOM. Чтобы прочитать их значения, используются рефы.

```

Если мы говорим про управляемые компоненты, то это элементы, которые контролирует React. Оно связано с input, textarea, select. Для того чтобы сделать управляемый компонент, нужно чтобы значение этих элементов хранилось именно в состоянии React компонента, т.е. управлялось через setState/useState

Это неуправляемые компоненты - они хранят свои данные прямо в DOM. Чтобы прочитать их значения, используются рефы.


```

</details>

<details>
<summary> Что такое поднятие состояния в верх в React? </summary>
Это паттерн, которое с помощью одного состояние может быть использовано сразу для несколько компонентов. Обычно некоторые компоненты должны реагировать на одни и те же события или изменения состояния, поэтому необходимо каким-то образом уведомлять все компоненты когда что-то изменилось как раз и используется состояние поднятие вверх. Это означает что общее состояние должно быть поднятно до общего ближайшего предка
</details>

<details>
<summary> Назовите стадии (фазы) жизненного цикла (lifecycle) компонента? </summary>

Жизненный цикл компонента состоит из трех отдельных фаз жизненного цикла:

- Moundting (монтирование) => компонент готов к монтированию в DOM браузера. Методы: constructor(), getDerivedStateFromProps(), render()и componentDidMount()жизненного цикла.
- Updating (обновление) => компонент обновляется при изменении его состояния через hook useState или передача пропcов.
- Unmounting (размонтирование) => на последнем этапе компонент не нужен и размонтируется из DOM браузера
</details>

<details>
<summary> Каковы методы жизненного цикла React? </summary>

1. shouldComponentUpdate() - когда нам необходимо указать следующий рендер на основе изменений состояния и пропсов. Он вызывает перед рендером, когда получает новые пропсы или состояние
2. static getDerivedStateFromProps() - вызывается непосредственно перед вызовом метода render. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять. Он необходим когда состояние зависит от изменений в просах
3. getSnapshotBeforeUpdate() - вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет компоненту брать некоторую информацию из DOM перед её возможным изменением.
4. static getDerivedStateFromError() и componentDidCatch() - вызывается после возникновения ошибки у компонента-потомка.
</details>

<details>
<summary> Что такое компоненты высшего порядка? </summary>

Компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент. Она смотрит на входящие пропсы и принимает на их основании решение : перерисовывать или не перерисовывать.

</details>

<details>
<summary>  Что такое контекст? </summary>

Он разработан для передачи данных от одного компонента к другой избегая промежуточные компоненты. Например: избегая пропс дриблинга. Чтобы создать контекст нужно написать React.createContext(), затем используя provider мы оборачиваем наш компонент, в нем мы также задать значения, а чтобы получить доступ необходимо обернуть в Consumer()

</details>

<details>
<summary>  Что такое props.children? </summary>

Это контент между открывающим и закрывающим тегом компонента. Например: `<Welcome>Привет, мир!</Welcome>` Для классовых компонентов используйте this.props.children:

</details>



<details>
<summary> Что такое компонент-переключатель (Switching Component)? </summary>
Это компонент, который рендерит один из несколько компонентов. Так называемый своеобразный реакт - паттерн, который позволяет реализовать удобный механизм отрисовки нескольких компонентов на основании какого-нибудь условия. Основная идея - структура в виде объекта, которая содержит ключи и соответсвующие им компоненты. Получая пропсы компонент переключатель вытягивает из них значения ключа. После чего по этому значению возвращает нужный компонент, которому с помощью спред оператора передаются все пропсы.
<img src='./assets/Switch-component.PNG' alt="switchComponent"/>
</details>



---