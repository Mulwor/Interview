<details>
<summary>1. Перечислите основые типы TypeScript</summary>

В тайпскрипт есть 3 примитивных типа: string, number, boolean. Также мы эти примитивы можем обернуть в массив через квадратные скобки или Array<number> или объект через фигурные

- `Any` - работает по принципу, что его тип может быть любым, это все равно, что писать на чистом JavaScript.  

- `unknown` похож на тип any, но он более безопасный, то есть мы не можем ему сразу присвоить новый тип нам нужно сделать некую проверку через typeOf, instanceof и уже внутри написать тип который мы хотим сделать.  Результаты JSON.parse

- `void` - это тип, который предназначен только для того, чтобы показывать, что функция не возвращает никакое значение, тобишь нет return

- `never` использует тогда когда мы доходим до случая, который не может никогда произойти как в switch...case или редюсерах: default. Я его использую для доп.проверки компилятором, что какая-то ситуация реально не может произойти

</details>

<details>
<summary>2. Чем отличается Type/interface</summary>

- Синтаксис

- Если у нас есть тип и интерфейс, то интерфейс может наследоваться от типа, а тип через extends не может наследоваться. 

- Если мы хотим взять какой-то примитивный тип у type, то внутри interface мы можем обратится к типу объявленный через type 

- Если у нас есть два типа, то мы можем объединить через | (палочку), у интерфейса такой функции нету. 

- Типы с одинаковыми именами мы не можем писать, так как будет ругаться, а вот интерфейс можно и тем самым мы можем их расшираять

</details>

<details>
<summary>3. TypeGuard</summary>

typeguard - когда нам необходимо защитить какой-то тип. Мы делаем проверку, что у нас элемент может быть например null. if (element) и будет тайп гвардом;

The instanceof type guard
The typeof type guard

if ('name' in person) {
return person.name;
}


</details>

<details>
<summary>4. Generic</summary>


позволяют создавать компоненты, которые могут работать с различными типами данных, без необходимости повторного написания кода для каждого типа.

Обобщения представляют собой параметры типа, которые передаются в определение функции, класса или интерфейса, чтобы указать, что они должны работать с каким-то типом данных, который будет определен при использовании компонента.

```
function identity<T>(arg: T): T {
  return arg;
}

let result = identity<string>("Hello, world!");
console.log(result); // Output: Hello, world!

let numberResult = identity<number>(42);
console.log(numberResult); // Output: 42
```


</details>

2. Utility types

- Partial - делает все свойства объекта типа T необязательными.

- Required - делает все свойства объекта типа T обязательными.

- Readonly - делает все свойства объекта типа T доступными только для чтения.

- Pick - выбирает свойства объекта типа T с ключами, указанными в K.

- Exclude - У нас есть объединенный тип и он исключает какой-то обределенный тип

объединения стилей (|)
наследование (extend)

- Omit - у нас есть тип и нам необходимо одно из типов исключить

4. Enums - энамки юзается когда у нас есть фиксированное значение, и по сути это перечисление

