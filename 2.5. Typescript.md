<details>
<summary>1. Перечислите основые типы TypeScript</summary>

В тайпскрипт есть 3 примитивных типа: 
- строки; 
- числа; 
- булевое значение;

Если нам нужно мы можем написав состоящий из примитивов
- массив через Array либо квадратные скобки;
- объект
```
interface User {
	name: string,
	age: number
}
let arr: User[] = [];
arr.push({name: 'john', age: 30});
```

- any, который говорит, что тип может быть любой. Похож как на неявное приведения типов
- unknown - он похож на any но более безопасный. То есть если мы присвоили unknown, то мы не сможем присвоить ему новое значения

- void - используется тогда когда не возвращает значение (нет return)
- never - используется когда функция ничего не вернет `while(true) {}` и функция которая никогда не вернет значение и бросит ошибку 

```
function f(): never {
    throw new Error('Never return');
}
```
</details>

<details>
<summary>2. Чем отличается Type/interface</summary>

- Синтаксис
- Интерфейс можно расширять
- Интерфейсы можно сливать в один общий, написав одинаковое имя, а вот тип не даст этого сделать


</details>

2. Utility types

- Partial - делает все свойства объекта типа T необязательными.

- Required - делает все свойства объекта типа T обязательными.

- Readonly - делает все свойства объекта типа T доступными только для чтения.

- Pick - выбирает свойства объекта типа T с ключами, указанными в K.

- Exclude - У нас есть объединенный тип и он исключает какой-то обределенный тип

объединения стилей (|)
наследование (extend)

- Omit - у нас есть тип и нам необходимо одно из типов исключить

4. Enums - энамки юзается когда у нас есть фиксированное значение, и по сути это перечисление

5. typeguard - когда нам необходимо защитить какой-то тип. Мы делаем проверку, что у нас элемент может быть например null. if (element) и будет тайп гвардом;

The instanceof type guard
The typeof type guard

if ('name' in person) {
return person.name;
}

6. generic types

позволяют создавать компоненты, которые могут работать с различными типами данных, без необходимости повторного написания кода для каждого типа.

Обобщения представляют собой параметры типа, которые передаются в определение функции, класса или интерфейса, чтобы указать, что они должны работать с каким-то типом данных, который будет определен при использовании компонента.

```
function identity<T>(arg: T): T {
  return arg;
}

let result = identity<string>("Hello, world!");
console.log(result); // Output: Hello, world!

let numberResult = identity<number>(42);
console.log(numberResult); // Output: 42
```
