#### Секция TypeScript

<details>
<summary>1. Перечислите основые типы TypeScript</summary>

В тайпскрипт есть 3 примитивных типа: string, number, boolean. Также мы эти примитивы можем обернуть в массив через квадратные скобки или Array<number> или объект через фигурные

- `Any` - работает по принципу, что его тип может быть любым, это все равно, что писать на чистом JavaScript.  

- `unknown` похож на тип any, но он более безопасный, то есть мы не можем ему сразу присвоить новый тип нам нужно сделать некую проверку через typeOf, instanceof и уже внутри написать тип который мы хотим сделать.  Результаты JSON.parse

- `void` - это тип, который предназначен только для того, чтобы показывать, что функция не возвращает никакое значение, тобишь нет return

- `never` использует тогда когда мы доходим до случая, который не может никогда произойти как в switch...case или редюсерах: default. Я его использую для доп.проверки компилятором, что какая-то ситуация реально не может произойти

</details>

<details>
<summary>2. Чем отличается Type/interface</summary>

- Синтаксис

- Если у нас есть тип и интерфейс, то интерфейс может наследоваться от типа, а тип через extends не может наследоваться. 

- Если мы хотим взять какой-то примитивный тип у type, то внутри interface мы можем обратится к типу объявленный через type 

- Если у нас есть два типа, то мы можем объединить через | (палочку), у интерфейса такой функции нету. 

- Типы с одинаковыми именами мы не можем писать, так как будет ругаться, а вот интерфейс можно и тем самым мы можем их расшираять

</details>

<details>
<summary>3. Что такое type Guard?</summary>

TypeGuard - это runtime проверка, которая передается комплиятору тайпскрипту и информирует о том, что дальше будут определенные типы (или мы попробуем сузить типы до определенных). К тайп гвардом можно отнести - `typeof; instanceOf; in (проверяет есть определенное св-в в объекте); if...else; строгое сравнения`
</details>

<details>
<summary>4. Что такое generic</summary>

Generic нужны нам тогда, когда мы не знаем четкий тип, которые передаются к нам в параматеры. C помощью дженериков мы говорим ТС определи сам тип `переданного нам аргумента`.

Где можно использовать generic? - Типы, интерфейс, классы, функции

Также есть ограничение, например он (дженерик) определяет стрингу и не разделяет, что это может быть даже в массиве стринга, в этом случае нам нужно extends.

</details>


<details> 
<summary>5. Utility types </summary>

Utility `[juː'tɪlətɪ]` types - это встроенные типы, которые помогают, как-то манипулировать типами

0. Record - создает тип, который представляют объекты с заданными ключами и значениями.  Она позволяет определить тип объекта, где все ключи имеют один и тот же тип значения.

1. Pick - нужен когда у нас есть тип, и мы хотим создать новый тип со свойствами другого типа

2. Omit - создает тип, исключая набор свойств из другого типа

3. Extract - создает тип, выбирая набор свойств из другого типа с union type (объединением стилей)

4. Exclude - создает тип, исключая набор свойств из другого типа с union type (объединением стилей)

5. NonNullable - создает тип, исключая набор свойств из другого типа null и undefined с union type (объединением стиля)

6. Partial - делает все свойства необязательным

7. Required - делает все свойства обязательными

8. Readonly - создает тип, свойства которых нельзя изменить

9. Parameters - работает с функциями, он достает аргумент и добавляет в кортеж(tuple) похожий на массив, где хранятые разные типы значений

10. ReturnType - достает возвращаемое значение. 

11. Awaited - позволяет получить тип, который будет возвращен после ожидания(awaiting) промиса.

</details>


