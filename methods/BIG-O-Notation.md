3. O(log n) - логарифмическая сложность - если массив отсортирован, мы можем проверить, есть ли в нём акое-то конкретное значение, методом деления пополам. Проверим средний элемент, если он больше искомого, то отбросим вторую половину массива — там его точно нет. Если же меньше, то наоборот — отбросим начальную половину. И так будем продолжать делить пополам, в итоге проверим log n элементов. Данная сложность используется в: бинарном поиске, деревье, сортировке, криптографии, структура данных по типу heap, графы

4. O(N*log N) -  линейно-логарифмическая сложность - чем больше данных нужно обработать, тем больше времени понадобится. Для понимания, давайте представим себе задачу сортировки книг в библиотеке. Если у вас 10 книг, сортировка может занять, скажем, 10 минут. Но если у вас 1000 книг, сортировка может занять 1000 * log(1000) минут, что означает 3000 минут. Например: быстрая сортировка или сортировка пузырьком

6. O(n2) - квадратная сложность - время выполнения алгоритма будет пропорционально квадрату размера входных данных. Например: сортировка пузырьком или сортировка выбором

7. O(2n) - экспоненциальная сложность - время выполнения алгоритма или функции растет линейно с увеличением размера входных данных, причем пропорционально удвоенному размеру данных. Например: 
```
// Упрощается до O(n)
function printNumbersTwice(n) {
  for (let i = 0; i < 2 * n; i++) {
    console.log(i);
  }
}
========================================
// Не упрощается
function printNumbersTwice(arr) {
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
  
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
}
```
В этой функции printNumbersTwice, мы используем цикл, который выполняется 2 * n раз. Это означает, что входной параметр n влияет на количество итераций цикла.


8. O(n!) - факториальная сложность - время выполнения алгоритма или функции растет факториально с увеличением размера входных данных. Факториал, обозначаемый как "n!", равен произведению всех положительных целых чисел от 1 до n. Это очень быстро растущая функция, и алгоритмы с временной сложностью "O(n!)" становятся очень неэффективными при увеличении размера входных данных. Например: перебор всех перестановок массива:

```
function generatePermutations(arr) {
  const result = [];

  function permutate(current, remaining) {
    if (remaining.length === 0) {
      result.push(current);
    } else {
      for (let i = 0; i < remaining.length; i++) {
        const newArray = [...current, remaining[i]];
        const newRemaining = [...remaining.slice(0, i), ...remaining.slice(i + 1)];
        permutate(newArray, newRemaining);
      }
    }
  }

  permutate([], arr);
  return result;
}

const inputArray = [1, 2, 3];
const permutations = generatePermutations(inputArray);
console.log(permutations);
```
