<details>
<summary>1. Типы объектов JavaScript?</summary>
Объекты - это тип данных, которые преназначены для хранения различных значений с помощью ключа и значения и выделяют следующие типы объектов - функции, массив, даты и коллекция: maps и weakmaps, sets и weaksets
</details>


<details>
<summary>2. Разница между объектом и массивом</summary>

1. У массивов есть методы тех, которых нет у объекта, также и наоборот
2. Чтобы обратится к какому-то элементу в массиве мы должны использовать индекс от нуля. А у объекта обращение идет через точку
3. Также у массива есть свойство length - делает подсчет всех элементов внутри массива. 

</details>

<details>
<summary>3. Как в JavaScript создать объект</summary>

Существует несколько способов создания объекта:
1. С помощью переменной и фигурных скобок: `let user = {}`
2. С помощью ключевого слово new: `let user = new Person("Win")`
3. C помощью метода Object.сreate(): `let user = Object.create(person)`

</details>

<details>
<summary>4. Для чего используется ключевое слово new?</summary>

New - это один из способов создания экземпляр объекта: `let user = new Person("Win")`. 

Стоит отметить, что ключевое слово new делает 4 вещи: 
A. Создает новый пустой объект, который наследуется от prototype;
Б. К нему (объекту) привязывается значение this;
Г. Возвращает значение this, если в реализации не указано иное
</details>

<details>
<summary>5. Как определить наличие свойства в объекте?</summary>

Первый и второй способ вернет булевое значение

1. С помощью метод `.hasOwnProperty()`

2. С помощью оператора `in`

Отличия заключается в том, что оператор in проверяет наличие свойств не только в самом объекте но и в его `ПРОТОТИПАХ`, а `hasOwnProperty` проверяет наличие свойства только в основном объекте. 

3. Обратится к объекту напрямую с помощью индексовой натации. Если свойство есть в объекте, то оно вернет значение, а если его нет, то undefined: `console.log(obj['prop1']); => foo`

</details>

<details>
<summary> 6. Методы объекта: key(), values(), entries(), fromEntries() </summary>

1. `Object.keys()` - возвращает массив ключей
2. `Object.values()` - возвращает массив значений
3. `Object.entries()` - возвращает массив пар ключ и значения
4. `Object.fromEntries()` - он преобразует список пар: ключ и значение в объект

</details>


<details>
<summary> 7. Что такое деструктуризация? (деструктурирующее присваивание)</summary>

Деструктуризация появилась в ЕС6 и она позволяеть извлекает данные из массива или объекта с помощью определенного синтаксиса и записать их в переменную.

```
let arr = ["Ali", "Adigezalli"];
let [first, second] = arr;
console.log(first + " " + second); // * Ali Adigezalli
```
</details>

<details>
<summary>8. Разница между Rest (остаточными параметры) и Spread (операторами расширения)?</summary>

Синтаксис одинаковый, однако задачи выполняют разные

Rest `(остаточные параметры)`. => Например у нас есть функция, и к нам приходят очень много параметров. Мы можем взять первые два параметра (a, b), а остальные параметры мы можем получить с помощью rest-оператора. Первые два параметра придут в качестве обычных значений, а рест оператор придет в виде массива

Spread `(оператор расширение)` - расширяет массив, объект. У нас есть в базе данных большой массив с пользователями и нам необходимо его скопировать и добавить пару новых пользователей и чтобы это сделать мы можем использовать spread оператор

</details>


<details>
<summary> 9. Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? </summary>

Например у нас есть объект с большой кучей вложенностей: массивов, объектов и т.д. И когда мы хотим копировать объект через spread оператор, то копируется лишь первый уровень вложенности, а остальные не копируются. Если нам нужно использовать глубокое копирование тут есть два варианта через JSON.parse и stringify или использовать спред оператор для всех уровней вложенностей, так мы получим глубокое копирование
</details>