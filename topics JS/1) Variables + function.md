#### V. Переменные и функции

<details>
<summary> 1. Правила задания имён для переменных и функций в JavaScript? </summary>

Если мы говорим задание имен переменных, то 

1. Они должны содержать буквы на латинице, он должен отражать смысл того, что он хранит: `let age = 20`;

2. Цифр: `let user2 = 'Antony';`

3. Символы доллара: `let $user = 'Alice';`

4. Нижнего подчеркивания: `let _user = 'Pete';`


Если мы говорим то, что как не стоит начинать, то - первый символ не должен быть цифрой: `let 10user = 'Nick';`          

Имя функции должно понятно и четко отражать что она делает и что возвращает. Функция - это действия по этому её имя 
обычно является глаголом: `function checkValue() {}`

</details>

<details>
<summary> 2. Разница между переменными: var, let и const </summary>

Существует несколько отличий между var, let и const:

1. let и const появились в ЕС6, а var был до ЕС6. 

2. Переменные var можно как занова объявлять, так и повторно обновлять, что не вызовет никакой ошибки в консоле. И с этим было много проблем 

3. У let мы можем присвоить новое значение, однако создавать переменную с тем же именем нельзя, а у const (если 
говорим про переменую), то мы не можем присвоить новое значение и не можем создать переменную с тем же именем. То 
есть переменная становится не изменяемой. 

4. У var область видимости - глобальная или локальная (область видимости в пределах функции). У `let` и `const` -
блочную область видимости, что в свою очередь означает любой элемент с фигурными скобками: функции, циклы, инструкции
(if ... else).

</details>

<details> 
<summary> 3. Что такое область видимости (Scope) и какие ты знаешь? </summary>

Область видимости - это место откуда мы имеем доступ к переменным или функциям. Выделяют 3 типа: 

1. `Глобальная область видимости` - это когда иы объявляем переменную внутри самого файла js (внутри скрипта) не 
оборачивая ни функцией, циклом. Они доступны из любого места в коде

2. `Локальная область видимости` - переменные и функции объявленные внутри функций, доступны только внутри этой 
функции и всем вложенным в неё функциям. За ее пределами, при обращении к переменной, мы получаем ошибку

3. `Блочная область видимости` - это когда переменная доступна только внутри блока, за пределеми блока она не доступна.

</details>

<details>
<summary> 4. Что такое необъявленная переменная и временная мертвая зона (temporal dead zone)? </summary>

1. `Необъявленная переменная` - это когда мы написали какое-то значение `a = 20` без переменных var, let либо const. 
Область видимости у необъявленных переменых - глобальная, что означает, что они доступны из любого места кода, что 
не очень хорошая практика как и var. Если мы будем использовать строгий режим, то получим ошибку ReferenceError, а в 
нестрогом undefined


2. `Временная мертвая зона` - Она появилась в ЕС6 и работает с let и const. Если мы сначало обратимся к переменной
до ее написания, в случае с var увидем ошибку undefined, так как вар появился значительно раньше временной мертвой 
зоны. Однако если мы сначало вызовем let или const до ее написания, то получим ошибку referenceError. Из чего можно 
сделать вывод, что временная мертвая зона означает, что к переменной мы не можем обратится пока она не будет вычислена

</details> 

<details>
<summary> 5. Разница между function declaration и function expression? </summary>

Выделяют два способа объявлении функции:

- `Function Declaration` – функция, которая объявлена через кл.слово function. Например: `function multyple() {...}`

- `Function Expression` – функция, которая объявление через переменную. Например: `let multiply = function () {...}`

Отличие заключает в том, что к function declaration можно вызвать до того как объявить. Так как JS собирает все строчки 
где объявляется function, а также через Hoisting (подним) их самый вверх, что позволяет нам сначало вызвать их, а потом
объявить. Еще наверное стоит отметить, что если мы объявим function expression через переменную var, то и она будет всплывать

</details>


<details>
<summary> 6. Разница между параметром и аргументом функции? </summary> 

Когда мы пишем функцию и внутри обычных скобок указываем a, b: `function value (a, b) {...}`, то это параметры. 
После того как мы передали параметры мы пишем код например `return a + b`. После вызываем этой функцию через запятую, 
так вот значения, которые передаются при вызове функции называются аргументами: foo (5, 7).  

</details>


<details>
<summary> 7. Как передаются параметры в функцию: по ссылке или по значению?</summary>

Примитивы передаются в функцию по значению, а объекыт и массив уже по ссылке. Стоит отметить, что когда в функции передается 
примитивное значение, то функция получает копию, а не примитивное знаечения, в то время как объект и массив передаются сам уже
 (оригинал) грубо говоря.  

</details>


<details>
<summary> 8. Что такое IIFE (перев. Анонимная самовызывающаяся функция)? </summary>

Если нам нужно вызвать функцию не через foo(), то мы можем использовать следующий метода. По правде говоря он уже устарел,
IIFE (Immediately Invoked Function Expression) - это анонимная функцию с лексической областью видимости, которая вызывается 
немедленно после его объявления. Cинтаксис: оздаёте функцию внутри круглых скобок и после закрывающей скобки, ещё ставьте 
круглые скобки.

</details>


<details>
<summary> 9.  Что такое замыкание (Closure)?  </summary>

Замыкание - оно создается при написании функции со своим лексич.окружение. И когда за пределами функции есть переменная, которого внутри нашего лексического окружения нет, то он
дает доступ обращатся к этой переменной.

</details>


<details>
<summary> Что такое чистая функция? (Pure Function) </summary>

Чистая функция - это та функция, у которой нет побочных эффектов и это функция, результаты которой зависят только от входных параметров. К побочным эффектом относится

К побочным эффектам относятся:

- Запросы на сервер
- Изменения входных параметров
- Обращение к дому (квериселекторы), если говорим про JS.

Плюсы чистых функций:

- Уменьшает кол-во багов (так как он максимально низко влияет на остальную систему. Если я знаю, что у меня есть баг в функции, то он внутри него)
- Легче тестировать
- Легче понимать, посколько все что она делает заключено внутри нее и не нужно никуда бегать.

</details>


<details>
<summary> Что такое рекурсия? </summary>

Рекурсия  - это функция, которая вызывает саму себя в теле этой же функции. Однако если мы не напишем условия, то цикл будет бесконечный, пока не выведится ошибка, что стек переполнен. Чтобы избежать данной ошибки необходимо условия выхода из функции. Например мы можем использовать рекурсию для вычисления чисел Фибоначчи или факториала

</details>


<details>
<summary> Что такое функции высшего порядка (Higher Order Functions)?  </summary>

HOF - обычная функция, которая принимает в качестве аргумента другую функцию, добавляет в эту функцию так скажем новый финкционал и возвращает его - это map, filter, reduce

<img src="../../assets/3.PNG" alt="Primer">

</details>

---

<details>
<summary> Разница между обычными функциями и стрелочными? </summary>

1. Синтаксис
2. У стрелочных функций нет своего this, оно берет его снаружи
3. У стрелочных функций нет arguments
4. Стрелочные функции не могут быть вызвани с new


</details>


<details>
<summary>  Что обозначает this в JavaScript? </summary>

Контекст определяет как функция была вызвана, что указывает на ключевое слово this в текущем участки кода

</details>


<details>
<summary> Разница между .call(), .apply() и bind()? </summary>

С помощью .call() - вызывает сразу функцию, первым параметром принимает контексте к которому необходимо привязать функию и через запятую передаю аргументы
С помощью .apply() - похож на .call только аргументы передаются внутри массива
C помощью .bind() - возвращает новую функцию привязанную в контекст, которую мы передали параметром.
</details>


--- 

Для кругозора, вероятность, что это спросят крайне маленькая

<details>
<summary> Типы функций по способности принимать другие функции? </summary>

В JS можно выделить 3 основные типов функций в зависимости от принимаемых данных:

- Функция первого класса (first-class functions) – это функция, которая не принимает другую функцию в качестве аргумента и не возвращает функцию как значения

`const firstOrder = () => console.log( “Hello”)`

- Функции высшего порядка (HOF) – это функция, которая принимает другую функцию в качестве аргумента или возвращает функцию как значение

`const higherOrder = firstOrderReturn => firstOrderReturn()`

- Унарная функция – это функция, которая принимает только 1 аргумент, который не является функцией.

`const unaryFunction = (a) => console.log(${a} + world!)`

</details>

<details>
<summary> Что такое полифил (polyfill)? </summary>

Например у нас есть современный код написанный на ЕС6, однако он не работает в старых браузерах, так вот с пмощью полифила мы можем преобразовать наши функции для старых бразуров. Вот пример: sessionStorage доступно во всех последних браузерах (IE8 и выше), но не в IE7 и ниже. Полифилл можно использовать для включения поддержки старых браузеров, которые не предоставляют файлы sessionStorage.

</details>


<details>
<summary> Что такое мемоизация? Реализуйте базовую логику функции для мемоизации? </summary>

Это прием создании функции способность запомнить ранее вычисленное значение, а также результат. В результате при повторном вызове функции с одинаковыми аргументами она не 
будет выполнена, а результат рбаоты вернется из кеша.

В программировании мемоизация — это метод оптимизации , который делает приложения более эффективными и, следовательно, более быстрыми. Он делает это, сохраняя результаты вычислений в кеше и извлекая ту же информацию из кеша в следующий раз, когда она потребуется, вместо того, чтобы вычислять ее снова.

</details>
