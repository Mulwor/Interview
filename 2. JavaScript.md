#### I. Типы данных

<details>
<summary> 1. Перечислите типы данных в JavaScript? </summary>
В JavaScript существует 8 типов данных, их можно разделить на примитивные и ссылочные. К примитивным относятся следующие типы:

- `string` (строка),

- `number` (число),

- `biginit`,

- `boolean`,

- `symbol` (уникальный идентификатор) - необходимо для создания уникальных id, чтобы создать его необходимо написать функцию Symbol(""). Если сравнить два одниковых символа между собой, они никогда не равны

- `null`,

- `undefined`

А к ссылочному относится:

- `object`. А определить тип данных можно с помощью typeOf.

<details>

<details>
<summary>Question: В чем отличие между null и undefined?</summary>

Стоит отметить, что разница между null и undefined в том, что `Undefined` - это когда переменная объявлена, но мы ей не присвоенно значение, а `null` - когда мы присвоили значение специально, и как бы говорим, что у нас есть переменная и она пустая.

</details>

</details>

<details>
<summary>Question: К какому типы данных относится массив и функция и чем они похожи?</summary>
Это все объект.
</details>

<details>
<summary> Question: В чем смысл объекта? И когда мы сравниваем объект, то что мы сравнимаем? </summary>
В нем можно хранить данные с помощью ключ и значения. Когда мы сравниваем объект, то мы сравниваем ссылки на объект
</details>

</details>

<details>
<summary>Question: Как превратить любой тип данных в булевое? Как преобразовать тип данных в булевой?</summary>

В JS мы можем явно преобразовать типы, всего их три: String(), Boolean(), Number() - и все они являются функциями.

Чтобы превартить тип данных в булевый можно использовать:

1. Функцию Boolean(null)
2. !! (Два логических не)

Чтобы превратить тип данных в числовое можно использовать:

1. Функцию Number('5')
2. метод parseInt("5")

Что превратить тип данных в строку можно использовать:

1. Функцию String(null)
2. Или через метод Object.prototype.toString(43)
</details>

<details>
<summary>Question: Перечислите все ложные значение? Перечислите falsy</summary>

Falsy - это следующие значение: "", 0, null, undefined, NaN, false. А все остальное уже true

</details>

<details>
<summary>Question: Что такое NaN? Как определить, что значение равно NaN?</summary>

NaN расшифровывается как not-a-number, что означает не является числом. Мы получаем его когда выполняем математическую операцию неправильно. Например, если мы возьмем строку и какое-то число, то оно нам даст NaN. А его особенностью можно выделить то, что она не равна ничему даже самому себе как в строгом, так и в нестрогом сравнении. Для того, чтобы проверить, что число не является числом использует функцию isNaN()

</details>

<details>
<summary>Question: разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?</summary>

Неявное преобразование происходит автоматически путем арифмитические действий, а явное когда мы указываем тип специально через функции Number или ParseInt, функцию String или метод toString, Boolean или двойное логическое !!

</details>

<details>
<summary>Question: JavaScript статически, или динамически типизированный язык? </summary>

Динамически типизированный язык, так как происходит автоматическое преобразование типов

</details>


<details>
<summary>Почему результат сравнения 2х объектов это false? </summary>

Примитивные типы данных сравниваются по значению, а объекты по ссылке. И если у нас две одинаковые объекты, то ссылки у них разные. Поэтому сравнения двух одинаковых объектов - это всегда false.

</details>

---

#### II. Операторы

<details>
<summary> 2. Какие операторы вы знаете? </summary>

I. Арифмитические операторы:

- сложения,
- вычитания,
- умножения,
- делание,
- возведение в стене `**`
- взятия от остатка `%`

II. Логические операторы:

- Или (||) - возвращает true, если одно из значений верно
- И (&&) - возвращает true только в том случае, если оба значеные верны, а вернет он последнее значение. Однако если все таки одно из значений false, то дальше он не пойдет.
- ! (Логическое не) - меняет значение на противоположное, стоит упомянуть также про

К особенностям стоит отметить, что есть также приоритетность, но если мы обернем в скобки то данная приоритетность уже не будет иметь разницы.

III. Операторы сравнения:

- больше, меньше, меньше или равно, больше или равно,
- нестрогое (==) и строгое равенство (===),
- не равно (!=).
</details>

<details>
<summary>Question: Чем отличается строгое равенство от нестрогового?</summary>

Строгое равенство отличается от нестрогого тем, что нестрогое сравнивает только значения без приведения типов, а строгая сравнивает и значения и типы

</details>

<details>
<summary>Question: Что такое двойное логическое не !!</summary>

Он нужен для преобразований значений к булевому значению.

Допилить идею: Если мы применим его к строке, то оно сначало станет булевое, а после этого к ней применится логическое отрицание.

</details>

<details>
<summary>Question: Что такое оператор нулевого слияние ??</summary>

Он возвращает значение правого операнда, если левый операнд содержит null или undefined, в противном случае возвращается значение левого операнда. Он похож на или, так как он возвращает правый операнд если в левом хранится ложное значение, а не только null / undefined

</details>

</details>

---

#### III. Циклы и инструкции

<details>
<summary>Что такое выражения (expression) и инструкции (statement) в JavaScript?</summary>

I. Выражение - это арифмитическое действие. Например:`+, -, *, /, %, >, =, ==, i++, --i`, `Math.random - случайное число.

II. Инструкция - это фрагмент кода, который выполняет определенное действие. К инструкциям относятся: `if, if-else, while, for, for..in, for..of switch, for-in, объявления переменных`

</details>


<details>
<summary>Что такое switch/case и где он используется? </summary>

Заменители if...else, внутри которого есть кейсы (те в свою очередь делают строгое сравнения между значения), и после каждого кейса необходимо писать break, если не указать, то проверка пройдет дальше


Если говорить про реакт, то используется он в редьюсерах (редаксе). И например когда нам нужно именно точное сравнения


</details>


<details>
<summary> Какие есть и как работают циклы в JS? </summary>

Цикл - это когда нам необходимо какое-то действие повторить несколько раз

- for (let i=..; i > str; i++)
- for ... in
- for ... of

- While... — сначала проверяет условия, а потом их выполняет, и так по кругу. Цикл будет повторятся пока условия верно
- Do...while — сначала выполняет условия, а потом их проверяет, и так по кругу.

</details>

<details>
<summary>В чем отличие между циклом for...in и for...of</summary>

Они служат для перебора объектов и массива. Если нам нужно перебрать объект, то мы использовать for...in, он возвращает нам ключи если нам необходимо перебрать массив, то мы используем for...of, он возвращает нам значенияю Однако если мы используем цикл for...in в массиве, то мы получем индексы.

</details>

---

#### IV. Методы в JavaSciprt

<details>
<summary>Number method</summary>

1. `Number.prototype.toString()` - берет число и преобразует его в строку
2. `Number.parseInt()` - берет строку и преобразует в число
3. `Number.isNaN()` - проверяет, является ли значения числа наном

</details>

<details>
<summary>Math method </summary>

Например у нас есть много чисел и если нам надо

1. `Math.min(1, 2, 3)` - вернуть минимальное число
2. `Math.max(2, 3, 4)` - вернуть максимальное число

Или если нам надо получить случайное число, то мы можем использовать `Math.random(1, 2, 3)`

Если нам надо будет округлить, то нам помогут следующие методы

1. `Math.random()` - округляет в ближайшему целому
2. `Math.floor()` - округляет в меньшую степень
3. `Math.ceil()` - округляет в большую степень

Есть также метод, который удаляет числа после точки - это `Math.trunc()`

</details>

<details>
<summary>String method</summary>

Если хотим мы написать с большой или маленькой буквы нам помогут следующие методы

1. `String.prototype.toUpperCase()` - берет строку и пишет ее с большой буквы. Преобразованное в верхний регистр.
2. `String.prototype.toLowerCase()` - берет строку и пишет ее с маленькой буквы. Преобразованное в нижний регистр.

Преобразовывае и удаляет символы

1. `String.prototype.toString()` - преобразовавает в строку
2. `String.prototype.split()` - делает из строки массив
3. `String.prototype.trim()` - удаляет пробельные символы с начало и конца строки

Методы строк: .startsWith() и .endsWith() проверяют начинается-ли (заканчивается) строка с определенным символом. 4. `String.prototype.startsWith()` => начинается ли строка с данного cлова

5. `String.prototype.endsWith()` => заканчивается ли строка с данным словом.

Они нужны для того, чтобы дополнять строку до нужного размер. Оба принимаются два аргументе: `длина (число)` и символ (строка), которая будет заполнять оставщуюся длину. Если его не указать, то он будет в видепустой строки

1. `String.prototype.padStart()` => подставляет дополнительные символы перед началом строки (слева)

2. `String.prototype.padEnd()` => подставляет дополнительные символы перед концом строки (справа)

Данные методы определяются начинается или заканчивается ли строка требуемыми символами, тем самым помогают определить соответствие в начале и в конце. Принимают два аргумент: `символы`, которые будут искаться в строке и второй `число`, с которого начнется поиск.

6. `String.prototype.replaceAll()` => у нас есть одно строковое предложение и мы хотим в этой предложенние заменить все слова на другие. Например: у кошки была кошка по имени Мушка, мы хотим кошку заменить на утку. Получается у утки была утка по имени Мушка.

</details>

<details>
<summary>Array method: isArray(); find(), findIndex(), indexOf(); push(); pop(); shift(); unshift(); forEact(); map()</summary>

1. `Array.isArray()` => проверяет является ли значение массивом

Следующие методы нужны для поиска в массиве. Они (find, findIndex) принимают в качестве аргумента функцию, только indexOf принимает в качестве аргумента обычное значение

2. `Array.prototype.find()` - вернёт первый найденный в массиве элемент, который подходит под условие.

3. `Array.prototype.findIndex()` - возвращает индекс первого найденного в массиве элемента, который подходит под условие, в противном случае -1 вернет

4. `Array.prototype.indexOf()` - вернётся индекс первого найденного элемента или -1, если ничего не нашлось

5. `Array.prototype.forEach()` и `Array.prototype.map()` => отличие заключается в том, что forEach() меняет исходный массив, а map возвращает новый. Еще одним отличиям является то, что если мы используем .map, то мы можем использовать
   и другие методы.

6. `Array.prototype.includes()` - определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false.

Данные методы меняют исходный массив - модифириует массив

7. `Array.prototype.push()` - добавляет элементы в конец массива и возвращает новую длину массива.

8. `Array.prototype.pop()` - удаляет из массива последний элемент и возвращает его значение.

9. `Array.prototype.shift()` - удаляет из массива первый элемент и возвращает его значение.

10. `Array.prototype.unshift()` - добавляет элементы в начало массива и возвращают новую длину массива.

Что будет работать быстрее? => Pop и push - так как их задача лишь добавить или удалить элемент в конце массива, а shift и unshift медленее так как помимо удаление или добавления первого элемент они будут сдвигать массив вправо или влево.

</details>

<details>
<summary>Array method: every(), some(), flat(), slice() and splice()</summary>

1. `Array.prototype.slice()` - копирует старый массив и на его основе создает новый. Он не преобразует его, а лишь берет копию определенного места, где мы указали индекс начало первым аргументом и конец его. Значения могут быть и отрицательным.

2. `Array.prototype.splice()` - нужен для удаления или добавления в или из массива. Аргументы: начальный индекс - это то с какого места нам необходимо начать. Второе значение - это сколько нам элементов нужно убрать. А также третьим параметрам говорим, что мы хотим добавить. Нужно отметить, что мы можем с конца начать отсчет (-1)

Следующие методы необходимы для перебора массива, они проверяются соответствует ли условия переданных в функции, после чего возвращают полученный результат в виде булеан.

3. `Array.prototype.some()` - перебирает массив и смотрит соответвствует ли один конкретный элемент в массиве логическому условию.

4. `Array.prototype.every()` - перебирает массив и смотрит соответвствует ли все элементы в массиве логическому условию.

```
[2, 5, 8, 1, 4].some(elem => elem > 10);                // false
[12, 5, 8, 1, 4].some(elem => elem > 10);               // true
[12, 5, 8, 130, 44].every(elem => elem >= 10);          // false
[12, 54, 18, 130, 44].every(elem => elem >= 10);        // true
```

5.  `Array.prototype.flat()` - у нас есть массив, внутри которого есть еще массивы и данный метод уменьшает вложенность массива на число которое мы указали внутри скобок, также мы можем написать Infinity и удалим все вложенности. Также его особенностью является удаления пустых строк

6.  `Array.prototype.flatMaP()` - это смесь двух методов: `.map` и введенного метода `flat` - сначала применяет функцию к каждому элементу, а потом преобразует полученный результат в плоскую структуру или раскрывает подмассивы и помещает их в массив
</details>

<details>
<summary>Что такое иммутабельность? И как достичь его? </summary>

Иммутабельность - это неизменяемый объект. Если мы хотим достичь иммутабельности, то мы можем использовать методы массива, такие как slice или map. К мутабельным относится push, shift, unshift, reverse. Если мы хотим, чтобы данные методы сработали, то есть были иммутабельными, то мы можем использовать spread оператор

</details>

---

#### Другое (пусть будет навсякий пожарный)

<details>
<summary> 1. Строгий режим (strict mode) в JavaScript?</summary>

Он появился в ЕС5, и он говорит, что наш код будет работать в строгом режиме в JS. Чтобы его использовать необходимо написать 'use strict' либо в начале скрипта либо внутри функции. Если мы его напишем в начале скрипта, то он будет иметь глобальную область видимости, а если напишем внутри функции, то будет иметь локальную область видимости. Например если мы объявим объект без переменной или продублируем параметры внутри функции

```
"use strict";
x = {p1:10, p2:20};      // This will cause an error
function x2(p1, p1) {};   // This will cause an error
```

</details>

<details>
<summary> 2. Типы всплывающих окон в JavaScript?</summary>

`alert` - выводить информацию во всплывающем окне;

`confirm` - спрашивать соглашение во всплывающем окне; подтвердить по ОК или Отмену

`prompt` - всплывающем окно, где просят написать что-то в инпут поле

</details>

<details>
<summary> 3. Типы ошибок в JavaScript? </summary>

1. SyntaxError - синтаксическая ошибка возникает когда мы написали неправильно какое-то слово: reutrn

2. RefferenceError - возникает когда js не может найти какую-то ссылку в которой мы пытаемся получить доступ. Например хотим определенную переменную найти а его нет

3. TypeError - возникает когда мы хотим методы определенных типов преобразовать на типов у которого этого метода нет.

</details>

<details>
<summary> 4. Что такое шаблонные литералы (Template Literals)?</summary>

Шаблонные литаралы - это обратные кавычки, внутри обратные кавычек мы можем с помощью знака доллара и фигурными скобками (${выражение}).

</details>

---

#### V. Переменные и функции

<details>
<summary> Правила задания имён для переменных и функций в JavaScript? </summary>

Если мы говорим задание имен переменных, то

1. Они должны содержать буквы на латинице, он должен отражать смысл того, что он хранит: `let age = 20`;

2. Цифр: `let user2 = 'Antony';`

3. Символы доллара: `let $user = 'Alice';`

4. Нижнего подчеркивания: `let _user = 'Pete';`

Если мы говорим то, что как не стоит начинать, то - первый символ не должен быть цифрой: `let 10user = 'Nick';`

Имя функции должно понятно и четко отражать что она делает и что возвращает. Функция - это действия по этому её имя
обычно является глаголом: `function checkValue() {}`

</details>

<details>
<summary> Разница между переменными: var, let и const </summary>

Существует несколько отличий между var, let и const:

1. let и const появились в ЕС6, а var был до ЕС6.

2. Переменные var можно как занова объявлять, так и повторно обновлять, что не вызовет никакой ошибки в консоле. И с этим было много проблем

3. У let мы можем присвоить новое значение, однако создавать переменную с тем же именем нельзя, а у const (если
   говорим про переменую), то мы не можем присвоить новое значение и не можем создать переменную с тем же именем. То
   есть переменная становится не изменяемой.

4. У var область видимости - глобальная или локальная (область видимости в пределах функции). У `let` и `const` -
   блочную область видимости, что в свою очередь означает любой элемент с фигурными скобками: функции, циклы, инструкции
   (if ... else).
тип
</details>

<details> 
<summary> Что такое область видимости (Scope) и какие ты знаешь? </summary>

Область видимости - это место откуда мы имеем доступ к переменным или функциям. Выделяют 3 типа:

1. `Глобальная область видимости` - это когда иы объявляем переменную внутри самого файла js (внутри скрипта) не
   оборачивая ни функцией, циклом. Они доступны из любого места в коде

2. `Локальная область видимости` - переменные и функции объявленные внутри функций, доступны только внутри этой
   функции и всем вложенным в неё функциям. За ее пределами, при обращении к переменной, мы получаем ошибку

3. `Блочная область видимости` - это когда переменная доступна только внутри блока, за пределеми блока она не доступна.

</details>

<details>
<summary> Что такое необъявленная переменная и временная мертвая зона (temporal dead zone)? </summary>

1. `Необъявленная переменная` - это когда мы написали какое-то значение `a = 20` без переменных var, let либо const.
   Область видимости у необъявленных переменых - глобальная, что означает, что они доступны из любого места кода, что
   не очень хорошая практика как и var. Если мы будем использовать строгий режим, то получим ошибку ReferenceError, а в
   нестрогом undefined

2. `Временная мертвая зона` - Она появилась в ЕС6 и работает с let и const. Если мы сначало обратимся к переменной
   до ее написания, в случае с var увидем ошибку undefined, так как вар появился значительно раньше временной мертвой
   зоны. Однако если мы сначало вызовем let или const до ее написания, то получим ошибку referenceError. Из чего можно
   сделать вывод, что временная мертвая зона означает, что к переменной мы не можем обратится пока она не будет вычислена

</details>

<details>
<summary> Разница между function declaration и function expression? </summary>

Выделяют два способа объявлении функции:

- `Function Declaration` – функция, которая объявлена через кл.слово function. Например: `function multyple() {...}`

- `Function Expression` – функция, которая объявление через переменную. Например: `let multiply = function () {...}`

Отличие заключает в том, что к function declaration можно вызвать до того как объявить. Так как JS собирает все строчки
где объявляется function, а также через Hoisting (подним) их самый вверх, что позволяет нам сначало вызвать их, а потом
объявить. Еще наверное стоит отметить, что если мы объявим function expression через переменную var, то и она будет всплывать

</details>

<details>
<summary> Разница между параметром и аргументом функции? </summary>

Когда мы пишем функцию и внутри обычных скобок указываем a, b: `function value (a, b) {...}`, то это параметры.
После того как мы передали параметры мы пишем код например `return a + b`. После вызываем этой функцию через запятую,
так вот значения, которые передаются при вызове функции называются аргументами: foo (5, 7).

</details>

<details>
<summary> Как передаются параметры в функцию: по ссылке или по значению?</summary>

Примитивы передаются в функцию по значению, а объекыт и массив уже по ссылке. Стоит отметить, что когда в функции передается примитивное значение, то функция получает копию, а не примитивное знаечения, в то время как объект и массив передаются сам уже (оригинал) грубо говоря.

</details>

<details>
<summary> Что такое IIFE (перев. Анонимная самовызывающаяся функция)? </summary>

Если нам нужно вызвать функцию не через foo(), то мы можем использовать следующий метода. По правде говоря он уже устарел,
IIFE (Immediately Invoked Function Expression) - это анонимная функцию с лексической областью видимости, которая вызывается
немедленно после его объявления. Cинтаксис: оздаёте функцию внутри круглых скобок и после закрывающей скобки, ещё ставьте
круглые скобки.

</details>

<details>
<summary> Что такое hoisting ?  </summary>

</details>

<details>
<summary> Что такое замыкание (Closure)?  </summary>

Замыкание - оно создается при написании функции со своим лексич.окружение. И когда за пределами функции есть переменная, которого внутри нашего лексического окружения нет, то он
дает доступ обращатся к этой переменной.

</details>

<details>
<summary> Что такое чистая функция? (Pure Function) </summary>

Чистая функция - это та функция, у которой нет побочных эффектов и это функция, результаты которой зависят только от входных параметров. К побочным эффектом относится

К побочным эффектам относятся:

- Запросы на сервер
- Изменения входных параметров
- Обращение к дому (квериселекторы), если говорим про JS.

Плюсы чистых функций:

- Уменьшает кол-во багов (так как он максимально низко влияет на остальную систему. Если я знаю, что у меня есть баг в функции, то он внутри него)
- Легче тестировать
- Легче понимать, посколько все что она делает заключено внутри нее и не нужно никуда бегать.

</details>

<details>
<summary> Что такое рекурсия? </summary>

Рекурсия - это функция, которая вызывает саму себя в теле этой же функции. Однако если мы не напишем условия, то цикл будет бесконечный, пока не выведится ошибка, что стек переполнен. Чтобы избежать данной ошибки необходимо условия выхода из функции. Например мы можем использовать рекурсию для вычисления чисел Фибоначчи или факториала

</details>

<details>
<summary> Что такое функции высшего порядка (Higher Order Functions)?  </summary>

HOF - обычная функция, которая принимает в качестве аргумента другую функцию, добавляет в эту функцию так скажем новый финкционал и возвращает его - это map, filter, reduce

<img src="./assets/3.PNG" alt="Primer">

</details>

---

Допы:

<details>
<summary> Допы: разница между синхронными и асинхронными функциями?</summary>

Синхронные функции являются блокирующими, а ассинхронные нет. Когда интерпретатор натыкается на синхронную функцию, он блокирует дальнейшее выполнения операции прежде чем данная функция будет выполнения. По этому набор таких функций выполняется последовательно - одна за другой. Ассинхронные функции наоборот не блокирует дальнейшие выполнения скрипта. По этой причине различные тяжелые операции по типу запроса данных делают ассинхронными. Обычно такие функции в качестве аргумента принимают коллбек - это еще одна функции, которая выполнится как только будет выполнено асинхронная функция и которая сможет обработать полученный результат

</details>

<details>
<summary> Типы функций по способности принимать другие функции? </summary>

В JS можно выделить 3 основные типов функций в зависимости от принимаемых данных:

- Функция первого класса (first-class functions) – это функция, которая не принимает другую функцию в качестве аргумента и не возвращает функцию как значения

`const firstOrder = () => console.log( “Hello”)`

- Функции высшего порядка (HOF) – это функция, которая принимает другую функцию в качестве аргумента или возвращает функцию как значение

`const higherOrder = firstOrderReturn => firstOrderReturn()`

- Унарная функция – это функция, которая принимает только 1 аргумент, который не является функцией.

`const unaryFunction = (a) => console.log(${a} + world!)`

</details>

<details>
<summary> Что такое полифил (polyfill)? </summary>

Например у нас есть современный код написанный на ЕС6, однако он не работает в старых браузерах, так вот с пмощью полифила мы можем преобразовать наши функции для старых бразуров. Вот пример: sessionStorage доступно во всех последних браузерах (IE8 и выше), но не в IE7 и ниже. Полифилл можно использовать для включения поддержки старых браузеров, которые не предоставляют файлы sessionStorage.

</details>

<details>
<summary> Что такое мемоизация? Реализуйте базовую логику функции для мемоизации? </summary>

Это прием создании функции способность запомнить ранее вычисленное значение, а также результат. В результате при повторном вызове функции с одинаковыми аргументами она не
будет выполнена, а результат рбаоты вернется из кеша.

В программировании мемоизация — это метод оптимизации , который делает приложения более эффективными и, следовательно, более быстрыми. Он делает это, сохраняя результаты вычислений в кеше и извлекая ту же информацию из кеша в следующий раз, когда она потребуется, вместо того, чтобы вычислять ее снова.

</details>

---

#### VI. Ассинхронщина (подходы к работе: promise, callback, async/await)

<details>
<summary>Типы таймеров в JavaScript?</summary>

В JS есть два основных типа таймеров:

- `setTimeout(...)` - позволяет вызвать переданную функцию один раз через определенное время
- `setInterval(...)` - позволяет вызвать переданную функцию много раз через определенный интервал времени. Чтобы отменить `setInterval` мы можем использовать тип: `clearInterval()` и внутрь передаем переменную, где использовали `setInterval`.

</details>

<details>
<summary>Что такое коллбэк-функция (Callback)? Что такое Callback Hell?</summary>

Коллбэк-функция - это функция, которая передана в другую функцию в качестве аргумента. Например: коллбеки могут используются при обращение к Апи, когда нам необходимо дождатся ответа, и после его получения мы можем выполнить какое-то действия. Он может также использоваться в сеттаймауте вызвав функцию alert.

Стоит отметить, что есть такое понятие как callback hell, которая означает ад коллбеков, данный термин используется когда у нас внутри функции очень много коллбеков, что в свою очередь трудно читать, понимать и контролировать. Чтобы избежать его можно разделить на async и await, разделить на другие функции и вызвать их в качестве коллбека.

</details>

<details>
<summary>Что такое Promise? И расскажите про разницу между методами Promise.all(); Promise.any() и Promise.race()</summary>

Промисы - это один из способов работы с асинхронным кодом и промис содержит в себе 3 состояния: `pending` - ожидания; `resolved (fulfilled)` - выполнено успешно; `rejected` - выполнено с ошибкой. Чтобы создать промис нам необходимо использовать конструкцую так называемую new Promise, которая принимает в качестве аргумента функцию, а сама функция принимает в качестве аргумента: resolve и reject.

У промисов есть методы: `Promise.all()`, `Promise.any()`, `Promise.race()`

`Promise.all()` - работает следующим образом: у нас есть много промисов, он дожидается (ждет) выполнения всех промисов. И если оно выполнется успешно, то вернет массив значений от всех промисов, которые были ему переданы. Однако если хотя бы один промис будет выполнен не успешно, то он выведет нам последний промис, который выполнен неуспешно.

`Promise.allSettled()` - работает по тому же принципу, что и `Promise.all()`, однако ему не важно выполнится ли промис успешно или с ошибкой он в любом случае выполнится.

`Promise.any()` - работает следующим образом: у нас есть списков промисов, он дожидается выполнения первого успешного промиса (кл.слово успешного) и если он находится его, то он возвращает данные результат, а если нет, то выводит ошибку

`Promise.race()` - выполнится только первый промис (не имеет разницы ошибка или успешно), остальные будут игнорировать.

</details>

<details>
<summary>Преимущества использовании промисов вместо колбэков?</summary>

- Помогает избежать коллбек-хелл, который может быть нечитаемым

- Упрощает последовательное написание последовательного читаемого ассинхроного кода с помощью then, а также обработку ошибок с помощью catch()

- Методы промисов all, allSettled, any, race

- С использованием промисов можно избежать следующих проблем: колбэк-функция была вызвана слишком рано, поздно или вовсе не была вызвана; функция была вызвана слишком мало или слишком много раз; не удалось передать необходимую среду/параметры; были пропущены ошибки/исключения.

</details>

<details>
<summary>Что такое async/await? </summary>

Способ написание ассинхроного кода, который построен на основе промисов. Он заставляет код, который работает ассинхроно, выглядить как синхронный код. Ключевое слово async возвращает всегда промис, а кл.слово await можно использовать только внутри тело функции в котором вызван async. Eсли его исп без async то выведится ошибка.

Например: частный кейс с которым я столкнулся при запросе на бэк, мне необходимо было дождаться ответа от сервера после него эвейтом получить специальный токен для захода на сервер

</details>

<details>
<summary>Что такое Eventloop (цикл событий) и как он работает?</summary>

Eventloop - это бесконечный цикл, который ожидает поступления задач, выполняет их и затем снова ждет поступления новых задач. И у него есть механизм, который называется callStack, в котором лежат как микро, так и макротаски. К микротаскам например относятся: Promise а к макротаскам относятся: setTimeout, setInterval. Стоит отметить, что сначало будут выполнятся микротаски, а затем макротаски

</details>

---

#### VII. Объекты

<details>
<summary>1. Типы объектов JavaScript?</summary>
Объекты - это тип данных, которые преназначены для хранения различных значений с помощью ключа и значения и выделяют следующие типы объектов - функции, массив, даты и коллекция: maps и weakmaps, sets и weaksets
</details>

<details>
<summary>2. Разница между объектом и массивом</summary>

1. У массивов есть методы тех, которых нет у объекта, также и наоборот
2. Чтобы обратится к какому-то элементу в массиве мы должны использовать индекс от нуля. А у объекта обращение идет через точку
3. Также у массива есть свойство length - делает подсчет всех элементов внутри массива.

</details>

<details>
<summary>3. Как в JavaScript создать объект</summary>

Существует несколько способов создания объекта:

1. С помощью переменной и фигурных скобок: `let user = {}`
2. С помощью ключевого слово new: `let user = new Person("Win")`
3. C помощью метода Object.сreate(): `let user = Object.create(person)`

</details>

<details>
<summary>4. Для чего используется ключевое слово new?</summary>

New - это один из способов создания экземпляр объекта: `let user = new Person("Win")`.

Стоит отметить, что ключевое слово new делает 4 вещи:
A. Создает новый пустой объект, который наследуется от prototype;
Б. К нему (объекту) привязывается значение this;
Г. Возвращает значение this, если в реализации не указано иное

</details>

<details>
<summary>5. Как определить наличие свойства в объекте?</summary>

Первый и второй способ вернет булевое значение

1. С помощью метод `.hasOwnProperty()`

2. С помощью оператора `in`

Отличия заключается в том, что оператор in проверяет наличие свойств не только в самом объекте но и в его `ПРОТОТИПАХ`, а `hasOwnProperty` проверяет наличие свойства только в основном объекте.

3. Обратится к объекту напрямую с помощью индексовой натации. Если свойство есть в объекте, то оно вернет значение, а если его нет, то undefined: `console.log(obj['prop1']); => foo`

</details>

<details>
<summary> 6. Методы объекта: key(), values(), entries(), fromEntries() </summary>

1. `Object.keys()` - возвращает массив ключей
2. `Object.values()` - возвращает массив значений
3. `Object.entries()` - возвращает массив пар ключ и значения
4. `Object.fromEntries()` - он преобразует список пар: ключ и значение в объект

</details>

<details>
<summary> 7. Что такое деструктуризация? (деструктурирующее присваивание)</summary>

Деструктуризация появилась в ЕС6 и она позволяеть извлекает данные из массива или объекта с помощью определенного синтаксиса и записать их в переменную.

```
let arr = ["Ali", "Adigezalli"];
let [first, second] = arr;
console.log(first + " " + second); // * Ali Adigezalli
```

</details>

<details>
<summary>8. Разница между Rest (остаточными параметры) и Spread (операторами расширения)?</summary>

Синтаксис одинаковый, однако задачи выполняют разные

Rest `(остаточные параметры)`. => Например у нас есть функция, и к нам приходят очень много параметров. Мы можем взять первые два параметра (a, b), а остальные параметры мы можем получить с помощью rest-оператора. Первые два параметра придут в качестве обычных значений, а рест оператор придет в виде массива

Spread `(оператор расширение)` - расширяет массив, объект. У нас есть в базе данных большой массив с пользователями и нам необходимо его скопировать и добавить пару новых пользователей и чтобы это сделать мы можем использовать spread оператор

</details>

<details>
<summary> 9. Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? </summary>

Например у нас есть объект с большой кучей вложенностей: массивов, объектов и т.д. И когда мы хотим копировать объект через spread оператор, то копируется лишь первый уровень вложенности, а остальные не копируются. Если нам нужно использовать глубокое копирование тут есть два варианта через JSON.parse и stringify или использовать спред оператор для всех уровней вложенностей, так мы получим глубокое копирование

</details>


#### Data structure (структура данных): 

<details>
<summary>Какие структуры данных вы знаете</summary>

</details>


#### OOP and Solid

